<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on 生活、學習紀錄</title>
        <link>https://jyunyi-lin.github.io/posts/</link>
        <description>Recent content in Posts on 生活、學習紀錄</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
        <lastBuildDate>Thu, 29 Aug 2024 16:21:26 +0800</lastBuildDate>
        <atom:link href="https://jyunyi-lin.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>利用 Storybook 和 Jest 打造可靠的前端測試方案</title>
            <link>https://jyunyi-lin.github.io/posts/2024/08/%E5%88%A9%E7%94%A8-storybook-%E5%92%8C-jest-%E6%89%93%E9%80%A0%E5%8F%AF%E9%9D%A0%E7%9A%84%E5%89%8D%E7%AB%AF%E6%B8%AC%E8%A9%A6%E6%96%B9%E6%A1%88/</link>
            <pubDate>Thu, 29 Aug 2024 16:21:26 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2024/08/%E5%88%A9%E7%94%A8-storybook-%E5%92%8C-jest-%E6%89%93%E9%80%A0%E5%8F%AF%E9%9D%A0%E7%9A%84%E5%89%8D%E7%AB%AF%E6%B8%AC%E8%A9%A6%E6%96%B9%E6%A1%88/</guid>
            <description>在現代前端開發中，我們經常會面對這樣的挑戰：如何確保我們的 UI 元件在不同的使用場景下都能穩定運作？如何在不斷變化的需求中保持程式碼的高品質？這些問題通常讓開發者頭痛不已。然而，當我們將 Storybook 與 Jest 結合起來使用時，這些挑戰便能迎刃而解。
什麼是 Storybook？ Storybook 是一個 UI 開發工具，能夠讓我們在獨立的開發環境中構建並測試 UI 元件。我們可以為每個元件建立「故事」（stories），這些「故事」展示了元件在不同狀態下的樣子。例如，一個按鈕元件可以在正常、懸停、禁用等狀態下呈現。這不僅方便我們開發，也讓設計師和 PM 可以直觀地看到元件的效果。
什麼是 Jest？ Jest 是一個強大的 JavaScript 測試框架，它簡單易用，支援斷言、模擬、非同步測試等功能。透過 Jest，我們可以撰寫單元測試和整合測試來確保程式碼的正確性。此外，Jest 還具備快照測試（Snapshot Testing）的功能，可以自動生成元件的快照並檢查變更。
Storybook 與 Jest 的完美結合 當我們將 Storybook 與 Jest 結合使用時，便能實現一個強大的測試方案。具體來說，我們可以利用 Storybook 的 stories 作為 Jest 測試的基礎，這樣可以保證所有的 UI 元件都被全面測試到。
步驟 1：設定 Storybook 和 Jest 首先，我們需要在專案中安裝並設定 Storybook 和 Jest。這可以透過以下命令來完成：
npx sb init npm install --save-dev jest babel-jest @testing-library/react @testing-library/jest-dom 接著，在 package.json 中配置 Jest：
&amp;#34;scripts&amp;#34;: { &amp;#34;test&amp;#34;: &amp;#34;jest&amp;#34; }, &amp;#34;jest&amp;#34;: { &amp;#34;setupFilesAfterEnv&amp;#34;: [&amp;#34;@testing-library/jest-dom/extend-expect&amp;#34;], &amp;#34;testEnvironment&amp;#34;: &amp;#34;jsdom&amp;#34; } 步驟 2：建立 Storybook 的 Stories 假設我們有一個 Button 元件，我們可以在 Button.</description>
            <content type="html"><![CDATA[<p>在現代前端開發中，我們經常會面對這樣的挑戰：如何確保我們的 UI 元件在不同的使用場景下都能穩定運作？如何在不斷變化的需求中保持程式碼的高品質？這些問題通常讓開發者頭痛不已。然而，當我們將 <strong>Storybook</strong> 與 <strong>Jest</strong> 結合起來使用時，這些挑戰便能迎刃而解。</p>
<h2 id="什麼是-storybook">什麼是 Storybook？</h2>
<p><strong>Storybook</strong> 是一個 UI 開發工具，能夠讓我們在獨立的開發環境中構建並測試 UI 元件。我們可以為每個元件建立「故事」（stories），這些「故事」展示了元件在不同狀態下的樣子。例如，一個按鈕元件可以在正常、懸停、禁用等狀態下呈現。這不僅方便我們開發，也讓設計師和 PM 可以直觀地看到元件的效果。</p>
<h2 id="什麼是-jest">什麼是 Jest？</h2>
<p><strong>Jest</strong> 是一個強大的 JavaScript 測試框架，它簡單易用，支援斷言、模擬、非同步測試等功能。透過 <strong>Jest</strong>，我們可以撰寫單元測試和整合測試來確保程式碼的正確性。此外，<strong>Jest</strong> 還具備快照測試（Snapshot Testing）的功能，可以自動生成元件的快照並檢查變更。</p>
<h2 id="storybook-與-jest-的完美結合">Storybook 與 Jest 的完美結合</h2>
<p>當我們將 <strong>Storybook</strong> 與 <strong>Jest</strong> 結合使用時，便能實現一個強大的測試方案。具體來說，我們可以利用 <strong>Storybook</strong> 的 stories 作為 <strong>Jest</strong> 測試的基礎，這樣可以保證所有的 UI 元件都被全面測試到。</p>
<h3 id="步驟-1設定-storybook-和-jest">步驟 1：設定 Storybook 和 Jest</h3>
<p>首先，我們需要在專案中安裝並設定 <strong>Storybook</strong> 和 <strong>Jest</strong>。這可以透過以下命令來完成：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>npx sb init
</span></span><span style="display:flex;"><span>npm install --save-dev jest babel-jest @testing-library/react @testing-library/jest-dom
</span></span></code></pre></div><p>接著，在 <code>package.json</code> 中配置 Jest：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span><span style="color:#e6db74">&#34;scripts&#34;</span><span style="color:#960050;background-color:#1e0010">:</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;test&#34;</span>: <span style="color:#e6db74">&#34;jest&#34;</span>
</span></span><span style="display:flex;"><span>}<span style="color:#960050;background-color:#1e0010">,</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;jest&#34;</span><span style="color:#960050;background-color:#1e0010">:</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;setupFilesAfterEnv&#34;</span>: [<span style="color:#e6db74">&#34;@testing-library/jest-dom/extend-expect&#34;</span>],
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;testEnvironment&#34;</span>: <span style="color:#e6db74">&#34;jsdom&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="步驟-2建立-storybook-的-stories">步驟 2：建立 Storybook 的 Stories</h3>
<p>假設我們有一個 <code>Button</code> 元件，我們可以在 <code>Button.stories.jsx</code> 中建立它的 <strong>Stories</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">React</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;react&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">Button</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;./Button&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Example/Button&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">component</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">Button</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Primary</span> <span style="color:#f92672">=</span> () =&gt; &lt;<span style="color:#f92672">Button</span> <span style="color:#a6e22e">primary</span>&gt;<span style="color:#a6e22e">Primary</span> <span style="color:#a6e22e">Button</span>&lt;/<span style="color:#f92672">Button</span>&gt;;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Secondary</span> <span style="color:#f92672">=</span> () =&gt; &lt;<span style="color:#f92672">Button</span>&gt;<span style="color:#a6e22e">Secondary</span> <span style="color:#a6e22e">Button</span>&lt;/<span style="color:#f92672">Button</span>&gt;;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Disabled</span> <span style="color:#f92672">=</span> () =&gt; &lt;<span style="color:#f92672">Button</span> <span style="color:#a6e22e">disabled</span>&gt;<span style="color:#a6e22e">Disabled</span> <span style="color:#a6e22e">Button</span>&lt;/<span style="color:#f92672">Button</span>&gt;;
</span></span></code></pre></div><p>這些 Stories 描述了 <code>Button</code> 元件在不同狀態下的樣子。</p>
<h3 id="步驟-3撰寫-jest-測試">步驟 3：撰寫 Jest 測試</h3>
<p>接下來，我們可以基於 <strong>Storybook</strong> 的 <strong>Stories</strong> 撰寫 <strong>Jest</strong> 測試。例如，我們可以測試 <code>Button</code> 元件是否在不同狀態下正確渲染：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">React</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;react&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">render</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;@testing-library/react&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">Primary</span>, <span style="color:#a6e22e">Secondary</span>, <span style="color:#a6e22e">Disabled</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;./Button.stories&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;renders Primary Button&#34;</span>, () =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">getByText</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">render</span>(&lt;<span style="color:#f92672">Primary</span> /&gt;);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">expect</span>(<span style="color:#a6e22e">getByText</span>(<span style="color:#e6db74">&#34;Primary Button&#34;</span>)).<span style="color:#a6e22e">toBeInTheDocument</span>();
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;renders Secondary Button&#34;</span>, () =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">getByText</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">render</span>(&lt;<span style="color:#f92672">Secondary</span> /&gt;);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">expect</span>(<span style="color:#a6e22e">getByText</span>(<span style="color:#e6db74">&#34;Secondary Button&#34;</span>)).<span style="color:#a6e22e">toBeInTheDocument</span>();
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;renders Disabled Button&#34;</span>, () =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">getByText</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">render</span>(&lt;<span style="color:#f92672">Disabled</span> /&gt;);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">expect</span>(<span style="color:#a6e22e">getByText</span>(<span style="color:#e6db74">&#34;Disabled Button&#34;</span>)).<span style="color:#a6e22e">toBeDisabled</span>();
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>這樣的測試確保了 <code>Button</code> 元件在每個狀態下都能正常運作。</p>
<h3 id="步驟-4結合快照測試">步驟 4：結合快照測試</h3>
<p>除了基本的渲染測試，我們還可以利用 <strong>Jest</strong> 的快照測試來追踪 UI 的變化。這可以幫助我們在不經意地修改了元件外觀時，及時發現並確認這些變更是否符合預期。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;Primary Button matches snapshot&#34;</span>, () =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">asFragment</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">render</span>(&lt;<span style="color:#f92672">Primary</span> /&gt;);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">expect</span>(<span style="color:#a6e22e">asFragment</span>()).<span style="color:#a6e22e">toMatchSnapshot</span>();
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><h3 id="結語">結語</h3>
<p>將 <strong>Storybook</strong> 與 <strong>Jest</strong> 結合使用，不僅能提高開發過程中的效率，還能確保元件的穩定性和一致性。這樣的測試方案能夠讓我們在面對複雜的 UI 元件時更加自信，並且減少因為程式碼變動而引發的潛在問題。透過這種方法，我們能夠更好地管理元件的品質，讓開發流程變得更加流暢，最終為使用者提供更好的體驗。</p>
<p>這篇文章希望能夠啟發你在開發流程中導入這樣的測試方案，並享受到 <strong>Storybook</strong> 與 <strong>Jest</strong> 帶來的便利和可靠性。如果你還沒有試過這種組合，那就趕快動手吧！</p>
]]></content>
        </item>
        
        <item>
            <title>前端開發者的 GA 基礎知識入門</title>
            <link>https://jyunyi-lin.github.io/posts/2024/08/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC%E8%80%85%E7%9A%84-ga-%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98%E5%85%A5%E9%96%80/</link>
            <pubDate>Sat, 24 Aug 2024 21:59:52 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2024/08/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC%E8%80%85%E7%9A%84-ga-%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98%E5%85%A5%E9%96%80/</guid>
            <description>前言 在開發專案時，客戶經常會要求進行網站數據分析，像是頁面瀏覽排行、取消訂閱次數、文件下載排名、站內搜尋關鍵字統計等。團隊在討論後，選擇了 Google Analytics (GA) 作為分析工具，此時 PM 通常會尋求開發者的協助來決定哪些數據需要前端的配合、需要進行哪些設定以及如何在程式碼中埋設追蹤事件。
假設我們是第一次接觸 GA，可能會開始尋找相關資料，瞭解 GA 的設置流程、如何設定以滿足客戶需求。然而，大部分資料都是介紹 GA 後台的使用或數據分析技巧，從開發者角度出發的指南相對稀少。要從大量資料中找到合適的內容並不容易，尤其是在專案中需要快速作出決策時。
因此，這篇文章將從前端開發者的角度，介紹 GA 的基本概念，並不會過多介紹 GA 的詳細功能，而是提供一個大方向，幫助前端工程師瞭解如何在 GA 的框架下進行有效的協作，使專案更為出色。
備註：本文的範例皆基於 GA4 版本。
在認識 GA 之前，先理解資料分析的基本概念 GA 的功能相當豐富，剛接觸 GA 時，看到大量的圖表和資料，可能會讓人感到困惑：應該從哪裡開始？哪些部分是前端要處理的？哪些是其他人要處理的？如果要嵌入程式碼，應該怎麼做？這些問題的答案在哪裡找到？在搞清楚這些問題前，我們應該先暫時擱置 GA，回到資料分析的基本概念上。
在日常生活中，我們經常接觸到資料統計，比如投票就是一種資料搜集，記帳也是資料搜集。撇除網站和程式的結構，如果我們想進行資料統計，會如何做？可能會用紙筆記錄，或是使用記帳本，甚至使用方便的軟體工具。
簡單來說，資料統計可以拆解成兩個步驟：搜集資料 和 分析資料。每次使用者的行為會觸發一筆記錄，而這些記錄最終會被處理和分析。從這個角度來看，GA 的運作也離不開這兩件事，分別是 搜集事件 和 分析資料。
從程式角度思考 GA 的運作方式 如果你寫過 React，並使用過 Redux 進行狀態管理，那麼應該會對 dispatch 和 reducer 不陌生。dispatch 發送 action 後，reducer 接收到 action，並依據 action 對 state 進行變更。
GA 的運作與此類似。GA 中每次資料的搜集都被稱為一次 事件 (event)，而這些事件透過 GA 的 API 發送到 GA 後台進行處理。GA 的 API 結構與 Redux 的 action 相似，我們知道 action 會有 action type 和 action payload，事件 (event) 也會有 event name 和 payload。</description>
            <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>在開發專案時，客戶經常會要求進行網站數據分析，像是頁面瀏覽排行、取消訂閱次數、文件下載排名、站內搜尋關鍵字統計等。團隊在討論後，選擇了 Google Analytics (GA) 作為分析工具，此時 PM 通常會尋求開發者的協助來決定哪些數據需要前端的配合、需要進行哪些設定以及如何在程式碼中埋設追蹤事件。</p>
<p>假設我們是第一次接觸 GA，可能會開始尋找相關資料，瞭解 GA 的設置流程、如何設定以滿足客戶需求。然而，大部分資料都是介紹 GA 後台的使用或數據分析技巧，從開發者角度出發的指南相對稀少。要從大量資料中找到合適的內容並不容易，尤其是在專案中需要快速作出決策時。</p>
<p>因此，這篇文章將從前端開發者的角度，介紹 GA 的基本概念，並不會過多介紹 GA 的詳細功能，而是提供一個大方向，幫助前端工程師瞭解如何在 GA 的框架下進行有效的協作，使專案更為出色。</p>
<blockquote>
<p><strong>備註</strong>：本文的範例皆基於 GA4 版本。</p>
</blockquote>
<h2 id="在認識-ga-之前先理解資料分析的基本概念">在認識 GA 之前，先理解資料分析的基本概念</h2>
<p>GA 的功能相當豐富，剛接觸 GA 時，看到大量的圖表和資料，可能會讓人感到困惑：應該從哪裡開始？哪些部分是前端要處理的？哪些是其他人要處理的？如果要嵌入程式碼，應該怎麼做？這些問題的答案在哪裡找到？在搞清楚這些問題前，我們應該先暫時擱置 GA，回到資料分析的基本概念上。</p>
<p>在日常生活中，我們經常接觸到資料統計，比如投票就是一種資料搜集，記帳也是資料搜集。撇除網站和程式的結構，如果我們想進行資料統計，會如何做？可能會用紙筆記錄，或是使用記帳本，甚至使用方便的軟體工具。</p>
<p>簡單來說，資料統計可以拆解成兩個步驟：<strong>搜集資料</strong> 和 <strong>分析資料</strong>。每次使用者的行為會觸發一筆記錄，而這些記錄最終會被處理和分析。從這個角度來看，GA 的運作也離不開這兩件事，分別是 <strong>搜集事件</strong> 和 <strong>分析資料</strong>。</p>
<h2 id="從程式角度思考-ga-的運作方式">從程式角度思考 GA 的運作方式</h2>
<p>如果你寫過 React，並使用過 Redux 進行狀態管理，那麼應該會對 <code>dispatch</code> 和 <code>reducer</code> 不陌生。<code>dispatch</code> 發送 action 後，<code>reducer</code> 接收到 action，並依據 action 對 state 進行變更。</p>
<p>GA 的運作與此類似。GA 中每次資料的搜集都被稱為一次 <strong>事件 (event)</strong>，而這些事件透過 GA 的 API 發送到 GA 後台進行處理。GA 的 API 結構與 Redux 的 action 相似，我們知道 action 會有 action type 和 action payload，事件 (event) 也會有 event name 和 payload。</p>
<pre tabindex="0"><code class="language-javascript!" data-lang="javascript!">// GA API 架構
gtag(&#34;event&#34;, &lt;event-name&gt;, &lt;event-payload&gt;);

// 範例
gtag(&#34;event&#34;, &#34;search&#34;, {
  search_term: &#34;t-shirts&#34;
});
</code></pre><p>前端開發者需要處理的就是事件 (event) 的觸發（資料搜集），而 GA 後台則專注於資料的分析。只要瞭解 GA API 的使用方式，我們就能根據專案需求，設置適當的事件來達成目標。</p>
<h2 id="進入-ga-之前的準備工作">進入 GA 之前的準備工作</h2>
<p>在開始使用 GA API 進行資料統計之前，有一些前置作業需要處理：</p>
<ol>
<li><strong>建立 Google Analytics 4 帳戶及資產 (property)</strong>： 這一步驟需要建立 GA 帳戶，這個帳戶將用來登入 GA 後台。實際上就是註冊一個帳號而已。</li>
<li><strong>為網站創建 Web 資料串流 (data stream)</strong>： GA 後台可以同時管理多個網站的數據分析，當有新網站需要加入 GA 時，需將該網站登錄到 GA 後台。</li>
<li><strong>在網站上嵌入 Google 標籤 (Google Tag)</strong>： 在 GA 後台提供的 JavaScript 程式碼片段，嵌入到專案中。完成這一步後，就可以在專案中使用 gtag (GA API) 方法了。</li>
</ol>
<p>完成前置作業後，GA 通常需要 1-2 天的時間才會開始搜集數據，並在後台顯示資料。</p>
<h2 id="ga-事件-event-的基本概念">GA 事件 (Event) 的基本概念</h2>
<p>GA 對前端開發者最重要的部分在於如何觸發正確的事件 (event)。GA 官方將事件分為四種類型：</p>
<ul>
<li>自動收集事件</li>
<li>加強評估事件</li>
<li>建議事件</li>
<li>自訂事件</li>
</ul>
<h3 id="自動收集事件">自動收集事件</h3>
<p>這些事件在完成前置作業後即會自動運作，無需開發者手動嵌入程式碼。常見的自動收集事件包含：</p>
<ul>
<li>廣告相關事件：<code>ad_impression</code>、<code>ad_click</code></li>
<li>App Store 相關事件：<code>app_store_subscription_cancel</code>、<code>app_update</code></li>
</ul>
<h3 id="加強評估事件">加強評估事件</h3>
<p>這些事件針對 Web 網站進行資料收集，需要在 GA 後台手動開啟。常見的加強評估事件包括：</p>
<ul>
<li><code>page_view</code>：每次網頁載入或瀏覽器記錄狀態變更時</li>
<li><code>scroll</code>：使用者第一次滾動到網頁底部時</li>
<li><code>click</code>：使用者點擊的連結將其帶離目前網域時</li>
</ul>
<h3 id="建議事件">建議事件</h3>
<p>這些事件針對「客戶」的操作進行資料收集，並需要前端開發者嵌入程式碼來觸發。常見的建議事件包括：</p>
<ul>
<li><code>sign_up</code>：使用者註冊</li>
<li><code>login</code>：使用者登入</li>
<li><code>add_to_cart</code>：使用者將商品加入購物車</li>
</ul>
<h3 id="自訂事件">自訂事件</h3>
<p>當預設和建議事件無法滿足需求時，開發者可以使用自訂事件來搜集自定義的資料。例如，搜集「取消訂閱」按鈕被點擊的次數，可以定義一個自訂事件 <code>unsubscribe</code> 並將其嵌入程式碼中。</p>
<pre tabindex="0"><code class="language-javascript!" data-lang="javascript!">// 自訂事件範例
const MySubscribe = ( ) =&gt; (
    &lt;button onClick={() =&gt; gtag(&#39;event&#39;, &#39;unsubscribe&#39;)}&gt;取消訂閱&lt;/button&gt;
);

export default MySubscribe;
</code></pre><h2 id="資料分析">資料分析</h2>
<p>當事件被觸發並發送到 GA 後台後，可以在 GA 後台中進行資料分析。如果是自訂事件，需要在後台新增事件，並設定分析規則。</p>
<h2 id="總結">總結</h2>
<p>GA 的核心在於資料的搜集與分析。對前端開發者來說，關注的重點在於 GA API 的使用，只要處理好事件的觸發，剩下的就交給 GA 後台的分析設定。</p>
<p>希望這篇文章能幫助前端開發者快速入門 GA，理解如何在專案中有效利用 GA 來達成資料分析的目標。</p>
]]></content>
        </item>
        
        <item>
            <title>初探 Google Maps API</title>
            <link>https://jyunyi-lin.github.io/posts/2024/01/%E5%88%9D%E6%8E%A2-google-maps-api/</link>
            <pubDate>Sat, 06 Jan 2024 17:44:01 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2024/01/%E5%88%9D%E6%8E%A2-google-maps-api/</guid>
            <description>當專案需要用到地圖時，應該首選都是 Google Map 提供的 API 服務。本文會先從 API 的介紹開始，慢慢進入如何應用到專案，接著詳細介紹在專案中使用到的 API，最後以一個概論作結。
Google Maps JavaScript API V3 介紹 因應不同的需求，主要可以分成七大類 API：
API 說明 範例 ❶Maps 顧名思義就是呼喚出那張地圖時所要使用的。自訂地圖樣式等。 ❷Drawing on the map 想在地圖上顯示出指定地點的 Marker 或甚至點擊 Marker 後要跳出一個 Info Window 嗎？內容都在這裡。 ❸Street View 街景服務 略 ❹Places 取得地點詳細資訊、經緯度變換地點都得用這組 API，也是本次會重點介紹的項目！ 詳見文章以下介紹 ❺Routes 導航路線相關。 略 ❻Local Context (beta) Local Context 將地圖、路徑規劃、地點 (Maps, Routes, Places) 功能，透過一支 API 全部整合，一次提供 3 種功能，似乎很讚，但還在 beta 中。 略 ❼Journey Sharing (beta) 顧名思義就是呼喚出那張地圖時所要使用的。自訂地圖樣式等。 略 在之前接觸的專案中，主要使用的主要是 ❶、❷，也就是使用 Google 地圖，並把相關店家的資訊（例如車咕嚕中洗車場地點）放置 Marker 在地圖上，點擊後會跳出店家詳細資訊及預約的 Info Window。 而本文主要想著重介紹的是 ❹，也是最近偉士牌需求中的購車頁優化，會需要依照使用者的 input 去移動到對應的城市，並顯示城市的名稱，其實就是模擬 Google Map 的搜尋功能，但實際做起來需要熟悉 API 的混用。</description>
            <content type="html"><![CDATA[<p>當專案需要用到地圖時，應該首選都是 Google Map 提供的 API 服務。本文會先從 API 的介紹開始，慢慢進入如何應用到專案，接著詳細介紹在專案中使用到的 API，最後以一個概論作結。</p>
<h2 id="google-maps-javascript-api-v3-介紹">Google Maps JavaScript API V3 介紹</h2>
<p>因應不同的需求，主要可以分成七大類 API：</p>
<table>
<thead>
<tr>
<th>API</th>
<th style="text-align:left">說明</th>
<th>範例</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://developers.google.com/maps/documentation/javascript/reference/map">❶Maps</a></td>
<td style="text-align:left">顧名思義就是呼喚出那張地圖時所要使用的。自訂地圖樣式等。</td>
<td><img src="https://i.imgur.com/nWprZ4w.png"></td>
</tr>
<tr>
<td><a href="https://developers.google.com/maps/documentation/javascript/reference/marker">❷Drawing on the map</a></td>
<td style="text-align:left">想在地圖上顯示出指定地點的 Marker 或甚至點擊 Marker 後要跳出一個 Info Window 嗎？內容都在這裡。</td>
<td><img src="https://i.imgur.com/ioUFTSI.png"></td>
</tr>
<tr>
<td><a href="https://developers.google.com/maps/documentation/javascript/reference/street-view">❸Street View</a></td>
<td style="text-align:left">街景服務</td>
<td>略</td>
</tr>
<tr>
<td><a href="https://developers.google.com/maps/documentation/javascript/reference/places-widget">❹Places</a></td>
<td style="text-align:left">取得地點詳細資訊、經緯度變換地點都得用這組 API，也是本次會<code>重點介紹的項目</code>！</td>
<td>詳見文章以下介紹</td>
</tr>
<tr>
<td><a href="https://developers.google.com/maps/documentation/javascript/reference/directions">❺Routes</a></td>
<td style="text-align:left">導航路線相關。</td>
<td>略</td>
</tr>
<tr>
<td><a href="https://developers.google.com/maps/documentation/javascript/reference/local-context-map-view#LocalContextMapViewOptions">❻Local Context (beta)</a></td>
<td style="text-align:left">Local Context 將地圖、路徑規劃、地點 (Maps, Routes, Places) 功能，透過一支 API 全部整合，一次提供 3 種功能，似乎很讚，但還在 beta 中。</td>
<td>略</td>
</tr>
<tr>
<td><a href="https://developers.google.com/maps/documentation/javascript/reference/journey-sharing-map-view">❼Journey Sharing (beta)</a></td>
<td style="text-align:left">顧名思義就是呼喚出那張地圖時所要使用的。自訂地圖樣式等。</td>
<td>略</td>
</tr>
</tbody>
</table>
<p>在之前接觸的專案中，主要使用的主要是 ❶、❷，也就是使用 Google 地圖，並把相關店家的資訊（例如車咕嚕中洗車場地點）放置 <code>Marker</code> 在地圖上，點擊後會跳出店家詳細資訊及預約的 <code>Info Window</code>。
而本文主要想著重介紹的是 ❹，也是最近偉士牌需求中的購車頁優化，會需要依照使用者的 input 去移動到對應的城市，並顯示城市的名稱，其實就是模擬 Google Map 的搜尋功能，但實際做起來需要熟悉 API 的混用。</p>
<h2 id="需求">需求</h2>
<ol>
<li>輸入 Enter 後將地圖定位至該縣市／區域並在列表顯示該搜尋區域<strong>所在縣市</strong>的名稱及所有分店。</li>
<li>移動地圖至其他縣市時，地圖：顯示可見地區的分店地標；列表：顯示地圖中心<strong>所在縣市</strong>的所有分店</li>
</ol>
<p>我們來拆解一下這個需求的實作步驟看看。</p>
<h3 id="需求--拆解">需求 ❶ 拆解</h3>
<ol>
<li>使用者輸入欲搜尋的區域，例如「豐原」、「綠島」</li>
<li>把這個 input 傳給 API，得到 response</li>
<li>response 應該就有郵遞區號，直接用這個去 mapping 城市表找出豐原是在臺中市；綠島是在臺東縣</li>
<li>地圖上呈現以豐原為中心的畫面、列表上印出臺中市</li>
</ol>
<h3 id="需求--拆解-1">需求 ❷ 拆解</h3>
<ol>
<li>使用者從 A 縣市拖曳到 B 縣市</li>
<li>監聽 DragEnd，發現地圖中心有改變就取得現在中心的經緯度丟到 API</li>
<li>從 response 整理出目前是在哪一個縣市</li>
<li>畫面改變</li>
</ol>
<h2 id="實作">實作</h2>
<p>首先，遵循 <a href="https://developers.google.com/maps/documentation/javascript/get-api-key">guide</a> 取得一組 API Key。
由於 Google Maps Platform 只提供原生 JS 或 TS，我們可以直接使用好心人士包裝成 <a href="https://www.npmjs.com/package/@react-google-maps/api">React 專用的套件</a>。</p>
<h3 id="基礎建設">基礎建設</h3>
<p><strong>※ 程式碼會省略 input 的 component</strong></p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">import React, { useState } from &#39;react&#39;
import { GoogleMap, useLoadScript } from &#39;@react-google-maps/api&#39;

const CustomGoogleMap = () =&gt; {
  // 載入 Places API 所需要的 libraries
  const [libraries] = useState([&#39;places&#39;])

  const { isLoaded, loadError } = useLoadScript({
    googleMapsApiKey: GOOGLE_MAP_API_KEY,
    libraries,
  })

  // 定義地圖的 style、各種控制等
  const renderMap = () =&gt; {
    const options = {
      disableDefaultUI: true,
      zoomControl: true,
      scaleControl: true,
      styles: mapStyle,
    }

   //todo1 處理使用者輸入的資料，實現需求❶
   //todo2：處理拖曳結束後的事件，實現需求❷

    return (
      &lt;&gt;
        &lt;GoogleMap
          mapContainerStyle={{
            width: &#39;100%&#39;,
            height: &#39;320px&#39;,
          }}
          center={center}
          zoom={12}
          options={options}
          onLoad={handleLoad}
          onDragEnd={handleCenterChanged}
        /&gt;
      &lt;/&gt;
    )
  }

  if (loadError) {
    return &lt;h1&gt;Map cannot be loaded right now, sorry.&lt;/h1&gt;
  }

  return isLoaded ? renderMap() : null
}
</code></pre><!-- raw HTML omitted -->
<h3 id="需求-">需求 ❶</h3>
<p>做好前置作業後，來實作需求 ❶ 吧！這邊我們需要運用到 Places 裡 <a href="https://developers.google.com/maps/documentation/javascript/reference/places-autocomplete-service">Autocomplete()</a> 來取得預測值，接著再將這個值丟給 <a href="https://developers.google.com/maps/documentation/javascript/reference/geocoder">Geocoder()</a> 轉換成經緯度，才能夠將中心點設為 input 的區域。如下圖 1：</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">// 處理使用者輸入的資料，實現需求❶
const handleKeyPress = event =&gt; {
	if (event.key === &#39;Enter&#39;) {
		const maps = window.google.maps;
		const sessionToken = new maps.places.AutocompleteSessionToken();
		const service = new maps.places.AutocompleteService();
		const request = {
			input: userInput,
			sessionToken,
			language: &#39;zh-TW&#39;, // 限定回傳語言為臺灣繁體中文
			types: [
				&#39;administrative_area_level_1&#39;,
				&#39;administrative_area_level_2&#39;,
				&#39;administrative_area_level_3&#39;,
			], // 限定回傳區域為 1~3 級行政區
		};
		service.getPlacePredictions(request, predictions =&gt; {
			const geocoder = new window.google.maps.Geocoder();
			geocoder.geocode({ placeId: predictions[0].place_id }, responses =&gt; {
				// 取得 input data 的經緯度後將地圖中間設為該值
				setCenter({
					lat: responses[0].geometry.location.lat(),
					lng: responses[0].geometry.location.lng(),
				});

				// 取得郵遞區號以用來 mapping 城市，例如 110 則對應到臺北市信義區
				setZipCode(responses[0].address_components.slice(-1)[0].long_name);
			});
		});
		// 使用 webview 開啟時需再按下 enter 後使用 blur() 以讓 portable device 鍵盤自動收起
		event.target.blur();
	}
};
</code></pre><!-- raw HTML omitted -->
<p>這樣第一個需求就完成囉～可以回顧上面的影片。</p>
<h3 id="需求--1">需求 ❷</h3>
<p>做完第一項之後，這個就很好理解了！直接看 code。</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">const handleCenterChanged = () =&gt; {
	// ❶將拖曳結束後的中心點放到 Geocoder(） 取得經緯度
	// ❷將資料處理後得到郵遞區號去做城市 mapping
};

//....

&lt;GoogleMap onDragEnd={handleCenterChanged}&gt;
</code></pre><!-- raw HTML omitted -->
<p>🎉🎉🎉🎉🎉 完成囉！ 🎉🎉🎉🎉🎉</p>
<h2 id="可以再優化的部分">可以再優化的部分</h2>
<ul>
<li>當 response 沒有回傳郵遞區號時，該如何去找到對應的城市？</li>
<li>如果使用者輸入非 1~3 級行政區（例如：陽明山），是否需提示 Alert？</li>
</ul>
<h2 id="結語">結語</h2>
<p>當初這個功能其實摸索了很久，主要在於 Google <del>很有商業頭腦地</del>把每一隻 API 回傳的 data 區分的很細，導致你要去組合兩三隻才能夠得到你要的結果。</p>
<p>每一隻 API 都是<a href="https://mapsplatform.google.com/intl/ja_ALL/pricing/">分開計費</a>的！如有專案需求可能會需要在開發前與 PM 討論，確認客戶接不接受收費方式，畢竟如果每一個拖曳都要打 API，即使有豐沛的免費額度也不得不注意～</p>
<h2 id="參考資料">參考資料</h2>
<blockquote>
<p><a href="https://developers.google.com/maps/documentation/javascript/reference">Google Maps JavaScript API V3 Reference</a> &gt; <a href="https://developers.google.com/maps/documentation/javascript/reference/places-autocomplete-service">Places Autocomplete Service</a> &gt; <a href="https://developers.google.com/maps/documentation/javascript/reference/geocoder">Geocoder</a> &gt; <a href="https://www.npmjs.com/package/@react-google-maps/api">@react-google-maps/api</a></p>
</blockquote>
<p><strong>PS: 以上程式碼如果凌亂或不符合大家的 code 標準請多多指教 🙏</strong></p>
]]></content>
        </item>
        
        <item>
            <title>簡單的開發 Git Flow</title>
            <link>https://jyunyi-lin.github.io/posts/2022/04/%E7%B0%A1%E5%96%AE%E7%9A%84%E9%96%8B%E7%99%BC-git-flow/</link>
            <pubDate>Sat, 16 Apr 2022 10:57:55 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2022/04/%E7%B0%A1%E5%96%AE%E7%9A%84%E9%96%8B%E7%99%BC-git-flow/</guid>
            <description>簡單的開發 Git Flow 不知道有沒有人遇到過做好的 feature A、B、C 都依序上了測試機，PM 卻說只要把 feature C 先上正式機的情況，這時候如果你的開發分支沒有管理好的話，就會非常 🥺
只有兩條主線 一般來說專案都會有正式跟測試環境，比較常見會分由 master &amp;amp; demo 等等分支來做開發。
假設你的 feature 或 issue 分支都是從 demo 開出來的，做完後又直接 merge 回 demo，那就有極大的機會遇到上面的窘境。
轉換 Base Branch 當然，你可以直接從 master 開 feature 分支來解決這個問題。
或在比較大型的專案，也可以多一個分支 staging 來當作開 branch 的 base，另外跟 PM 爭取多開一個上正式機前的測試環境，方便我們或 PM 測試每次上版的內容。
Branch 通常可以由以下幾個主要的 branch 來做版本控管。
master / production：正式環境：正式發佈出去的版本。 staging / stage：上正式機前的測試環境：可以把它當作開分支的基底，基本上內容要跟 master 的內容保持一致。 demo / develop：測試環境：會包含最多的功能開發以及 bug 修復。 不同的專案，可能還會有 pre-prod 等等更多的分支
開發流程 1. 當 issue 被 assign 過來</description>
            <content type="html"><![CDATA[<h1 id="簡單的開發-git-flow">簡單的開發 Git Flow</h1>
<p>不知道有沒有人遇到過做好的 feature A、B、C 都依序上了測試機，PM 卻說只要把 feature C 先上正式機的情況，這時候如果你的開發分支沒有管理好的話，就會非常 🥺</p>
<h3 id="只有兩條主線">只有兩條主線</h3>
<p>一般來說專案都會有正式跟測試環境，比較常見會分由 <code>master</code> &amp; <code>demo</code> 等等分支來做開發。<br>
假設你的 feature 或 issue 分支都是從 <code>demo</code> 開出來的，做完後又直接 merge 回 <code>demo</code>，那就有極大的機會遇到上面的窘境。</p>
<p><img src="https://i.imgur.com/E2Us5Ga.png"></p>
<h3 id="轉換-base-branch">轉換 Base Branch</h3>
<p>當然，你可以直接從 <code>master</code> 開 feature 分支來解決這個問題。<br>
或在比較大型的專案，也可以多一個分支 <code>staging</code> 來當作開 branch 的 base，另外跟 PM 爭取多開一個上正式機前的測試環境，方便我們或 PM 測試每次上版的內容。</p>
<h3 id="branch">Branch</h3>
<p>通常可以由以下幾個主要的 branch 來做版本控管。</p>
<ul>
<li>master / production：正式環境：正式發佈出去的版本。</li>
<li>staging / stage：上正式機前的測試環境：可以把它當作開分支的基底，基本上內容要跟 <code>master</code> 的內容保持一致。</li>
<li>demo / develop：測試環境：會包含最多的功能開發以及 bug 修復。</li>
</ul>
<blockquote>
<p>不同的專案，可能還會有 <code>pre-prod</code> 等等更多的分支</p>
</blockquote>
<p><img src="https://i.imgur.com/RIblDmR.png"></p>
<h3 id="開發流程">開發流程</h3>
<p><strong>1. 當 issue 被 assign 過來</strong></p>
<p>可以從 <code>staging</code> 開新的分支： <code>issue/#1</code>、<code>issue/#2</code>，開發完成 merge 進 <code>demo</code> 請 PM 測試。</p>
<p><strong>2. 確定要上正式機</strong></p>
<p>當一個或多個 issue 確定要上到正式機，再將他們合進 <code>staging</code>。</p>
<blockquote>
<p>這時候如果有多一個上版前的測試環境就可以請 PM 測試。</p>
</blockquote>
<p><strong>3. release 新的版號</strong></p>
<p>如果測試都沒有問題，那就接著 release 新的版號吧！</p>
<p>這時候會產生一個 tag 可以用來當作版控。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git checkout -b release/版號
</span></span><span style="display:flex;"><span>yarn release
</span></span></code></pre></div><blockquote>
<p>記得也要把 tag 推上遠端喔</p>
</blockquote>
<p><strong>4. 發 MR 給 <code>master</code></strong></p>
<p>可以把 CHANGELOG.md 貼到 MR 的描述裡紀錄這次更版的變動。</p>
<p><strong>5. Merge</strong></p>
<p>完成 merge 之後記得把 release branch 也 merge 回 <code>staging</code> 讓版號也回我們的 branch base</p>
<blockquote>
<p>上正式機的 issue branch 也記得可以刪除，讓專案的分支保持乾淨喔</p>
</blockquote>
<h2 id="commit">commit</h2>
<p>另外，可以養成在 commit message 後面養成 reference 回 issue 的習慣，方便之後的追蹤跟維護喔。</p>
]]></content>
        </item>
        
        <item>
            <title>Core Web Vitals</title>
            <link>https://jyunyi-lin.github.io/posts/2022/04/core-web-vitals/</link>
            <pubDate>Thu, 07 Apr 2022 09:19:33 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2022/04/core-web-vitals/</guid>
            <description>網站體驗核心指標： LCP、FID、CLS，優化使用者體驗
使用者體驗 (User Experience) 使用者體驗，或 UX(User Experience)，即「任何產品、生活形式經過人為的設計後，使用上感受到的體驗」因此 UX 無所不在。從我們使用的浴廁設施、家具、到你喝的早餐店奶茶、滑的手機都是經過設計而成。
用戶體驗的設計師關心產品「何時」被使用，「如何」吸引人購買，以及購買後「如何」被使用。延伸到網站上，理所當然網站的載入速度、介面美觀、實用性、是否符合用戶的需求、用戶是否想再回訪，因此也與行銷、設計、工程和 SEO 息息相關。
網站體驗核心指標（Core Web Vitals） 2020 年 5 月 28 日， Google 在官方部落格中針對使用者體驗推出了新的 3 項 Core web vitals。用來測量訪客在頁面的瀏覽體驗狀況。每項指標皆代表使用者體驗不同的面相，並反映出以使用者為中心的真實體驗。
良好 需要改善 低落 LCP ≤2500ms &amp;gt;4000ms 75 FID ≤100ms &amp;gt;300ms 75 CLS ≤0.1 &amp;gt;0.25 75 每個核心指標的檢查結果都有良好、需要改善、不良三個區間
LCP (Largest Contentful Paint) — 顯示最大內容元素所需時間 [速度指標] LCP 注重於頁面中最大元素的載入速度，簡言之就是網頁從開始等待畫面載入，直到主要畫面載入完成，Google 建議於開始載入網頁的 2.5 秒內完成 LCP。
LCP 會偵測那些項目？ &amp;lt;img&amp;gt; elements 包在 &amp;lt;svg&amp;gt; element 裡面的 &amp;lt;image&amp;gt; elements &amp;lt;video&amp;gt; elements 透過 url() 的 CSS 功能 載入 background-image 的 element 包含 text node 或是 inline-level text elements children 的 block-level element LCP 該如何進行優化？ 通常 LCP 可以針對以下 4 大點來進行優化</description>
            <content type="html"><![CDATA[<blockquote>
<p>網站體驗核心指標： LCP、FID、CLS，優化使用者體驗</p>
</blockquote>
<h3 id="使用者體驗-user-experience">使用者體驗 (User Experience)</h3>
<p>使用者體驗，或 UX(User Experience)，即「任何產品、生活形式經過人為的設計後，使用上感受到的體驗」因此 UX 無所不在。從我們使用的浴廁設施、家具、到你喝的早餐店奶茶、滑的手機都是經過設計而成。</p>
<p>用戶體驗的設計師關心產品「何時」被使用，「如何」吸引人購買，以及購買後「如何」被使用。延伸到網站上，理所當然網站的載入速度、介面美觀、實用性、是否符合用戶的需求、用戶是否想再回訪，因此也與行銷、設計、工程和 SEO 息息相關。</p>
<h3 id="網站體驗核心指標core-web-vitals">網站體驗核心指標（Core Web Vitals）</h3>
<p>2020 年 5 月 28 日， Google 在<a href="https://developers.google.com/search/blog/2020/05/evaluating-page-experience">官方部落格</a>中針對使用者體驗推出了新的 3 項 Core web vitals。用來測量訪客在頁面的瀏覽體驗狀況。每項指標皆代表使用者體驗不同的面相，並反映出以使用者為中心的真實體驗。</p>
<p><img src="https://i.imgur.com/bv8yWq6.png"></p>
<table>
<thead>
<tr>
<th></th>
<th>良好</th>
<th>需要改善</th>
<th>低落</th>
</tr>
</thead>
<tbody>
<tr>
<td>LCP</td>
<td>≤2500ms</td>
<td>&gt;4000ms</td>
<td>75</td>
</tr>
<tr>
<td>FID</td>
<td>≤100ms</td>
<td>&gt;300ms</td>
<td>75</td>
</tr>
<tr>
<td>CLS</td>
<td>≤0.1</td>
<td>&gt;0.25</td>
<td>75</td>
</tr>
</tbody>
</table>
<p>每個核心指標的檢查結果都有<strong>良好、需要改善、不良</strong>三個區間</p>
<h3 id="lcp-largest-contentful-paint--顯示最大內容元素所需時間-速度指標">LCP (Largest Contentful Paint) — 顯示最大內容元素所需時間 [速度指標]</h3>
<p>LCP 注重於頁面中<strong>最大元素的載入速度</strong>，簡言之就是網頁從開始等待畫面載入，直到主要畫面載入完成，Google 建議於開始載入網頁的 <strong>2.5 秒</strong>內完成 LCP。</p>
<h3 id="lcp-會偵測那些項目">LCP 會偵測那些項目？</h3>
<ul>
<li><code>&lt;img&gt;</code> elements</li>
<li>包在 <code>&lt;svg&gt;</code> element 裡面的 <code>&lt;image&gt;</code> elements</li>
<li><code>&lt;video&gt;</code> elements</li>
<li>透過 <a href="https://developer.mozilla.org/zh-TW/docs/Web/CSS/url()">url() 的 CSS 功能</a> 載入 background-image 的 element</li>
<li>包含 text node 或是 inline-level text elements children 的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements">block-level element</a></li>
</ul>
<h3 id="lcp-該如何進行優化">LCP 該如何進行優化？</h3>
<p>通常 LCP 可以針對以下 4 大點來進行優化</p>
<ul>
<li>減少伺服器回應時間
<ul>
<li>針對主機進行優化</li>
<li>使用較近的 CDN 主機</li>
<li>使用網頁快取</li>
<li>讓第三方的資源提早載入</li>
</ul>
</li>
<li>排除禁止轉譯的資源
<ul>
<li>降低 JavaScript 阻擋時間</li>
<li>降低 CSS 阻擋時間</li>
</ul>
</li>
<li>加快資源載入的時間
<ul>
<li>圖片大小優化</li>
<li>預先載入重要資源</li>
<li>將文字檔案進行壓縮</li>
<li>根據使用者的網路狀態提供不同的內容</li>
<li>使用 service worker</li>
</ul>
</li>
<li>避免使用客戶端渲染(CSR)
<ul>
<li>若必須使用 CSR ，建議優化 JavaScript ，避免渲染時使用太多資源</li>
<li>盡量在伺服器端完成頁面渲染，讓用戶端取得已渲染好的內容</li>
</ul>
</li>
</ul>
<h3 id="lcp-如何檢測">LCP 如何檢測</h3>
<p>可以使用 <a href="https://pagespeed.web.dev/">Google PageSpeed Insights</a> 檢查整體網站的 LCP 分數。如：</p>
<p><img src="https://i.imgur.com/h6LUxdU.png"></p>
<h3 id="fid--first-input-delay-首次輸入延遲封鎖時間總計-互動性指標">FID — First Input Delay 首次輸入延遲/封鎖時間總計 [互動性指標]</h3>
<p><strong>當使用者第一次與頁面進行互動，行為完成到瀏覽器成功回應給使用者的時間</strong>，根據 Google 的研究，100 ms 為「良好」的最低標準：如果處理輸入的延遲超過 100 ms，那麼其他處理和渲染步驟就沒有機會及時完成。</p>
<p>首次輸入 (First Input) 與頁面上的響應元件 (responsive elements) 息息相關。這些響應元件可能是連結、按鈕或是跳出式元素 (pop-ups)。</p>
<p>輸入延遲 (Input Delay) 通常發生於瀏覽器的主執行序過度繁忙，而導致頁面內容無法正確地與使用者進行互動。舉例來說，可能瀏覽器正在載入一支相當肥大的 JavaScript 檔案，導致其他元素不能被載入而延遲可互動的時間。
常見延遲的問題有：</p>
<ul>
<li>點選連結或按鈕載入內容延遲</li>
<li>文字對話框無法立即輸入文字</li>
<li>打開下拉式選單畫面延遲</li>
<li>無法勾選對話方塊</li>
</ul>
<p><img src="https://i.imgur.com/rSpjhsP.png"></p>
<h3 id="如何優化-fid">如何優化 FID</h3>
<ul>
<li><a href="https://web.dev/bootup-time/">減少 JavaScript 運作的時間</a></li>
<li><a href="https://web.dev/resource-summary/">降低網站的 request 數並降低檔案大小</a></li>
<li><a href="https://web.dev/mainthread-work-breakdown/">減少主執行序的工作</a></li>
<li><a href="https://web.dev/third-party-summary/">降低第三方程式碼的影響</a></li>
</ul>
<h3 id="cls--cumulative-layout-shift-累計版面配置轉移-穩定性指標">CLS — Cumulative Layout Shift 累計版面配置轉移 [穩定性指標]</h3>
<p>指網站在 Loading 讀取時有時會導致<a href="https://web.dev/cls/#expected-vs.-unexpected-layout-shifts">物件位移</a>，會導致使用者點不到想點擊的區塊。CLS 就是用來評估這部分的反應時間及網站的穩定度。應將 CLS 控制在<strong>0.1</strong> 或以下</p>
<blockquote>
<p>版面位移分數 (layout shift score) = 影響分數 (impact fraction) * 距離分數 (distance fraction)</p>
</blockquote>
<p><a href="https://github.com/WICG/layout-instability#Impact-Fraction">影響分數</a>：造成偏移區塊＋原本區塊所佔螢幕（viewport）比例</p>
<h3 id="頁面內容的意外移動通常是由於">頁面內容的意外移動通常是由於：</h3>
<ul>
<li>圖片缺少初始尺寸，所以等載入後寬高才會長出來</li>
<li>缺少尺寸的廣告、內嵌（embed）以及 iframe</li>
<li>動態置入內容</li>
<li>下載網站字體有機會造成頁面閃爍 FOIT(Flash of Invisible Text)、FOUT(Flash of Unstyled Text)</li>
<li>更新 DOM 前等待網路回應的動作</li>
</ul>
<h3 id="如何優化-cls">如何優化 CLS</h3>
<ul>
<li>圖片元素使用固定尺寸或設定寬高比 CSS</li>
<li>外部嵌入資源設定尺寸 (Ads, embeds, iframes)</li>
<li>避免使用動態插入內容</li>
<li>Preload 載入外部字體樣式</li>
</ul>
<p><a href="https://web.dev/i18n/zh/optimize-cls/">https://web.dev/i18n/zh/optimize-cls/</a></p>
<h3 id="cls-檢測">CLS 檢測</h3>
<p>同樣可以使用 <a href="https://pagespeed.web.dev/">Google PageSpeed Insights</a> 或 Lighthouse</p>
<p><img src="https://i.imgur.com/tNdOSd9.png"></p>
<p>或是 Chrome DevTools 的 Layout Shift 中查看：</p>
<p><img src="https://i.imgur.com/Zc28C6l.jpg"></p>
]]></content>
        </item>
        
        <item>
            <title>Vue.js 學習筆記 - 3</title>
            <link>https://jyunyi-lin.github.io/posts/2021/04/vue.js-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-3/</link>
            <pubDate>Mon, 19 Apr 2021 15:44:43 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2021/04/vue.js-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-3/</guid>
            <description>今天想來聊聊 Vue Router。
Vue Router 是由前端實作的路由，有了它，就可以透過前端操控路由，打造一個前端 SPA*。在過往路由需要先經過網路（Internet），並透過後端伺服器，進行請求與回應的動作，才能顯示路由指定的頁面，但是透過 Vue Router，就不一定需要網路與後端，也能渲染這個路由指定的頁面。
SPA 為 Single-page Application 的簡寫。指的是「不跳頁」的網頁設計原則，例如著名的 Gmail。所以你在用 Gmail 的時候，會感覺好像「在用一個 App」而不是在用「網頁」，因為頁面之間跳轉的很流暢，而不像一般網站一樣在操作過程需要不斷重整頁面。
使用 Vue Router 時，當我們想變更路由，會經過以下的步驟：
啟動 Vue Router 藉由 JavaScript 動態更改網址 載入對應的 component 渲染顯示頁面 但是當需要使用到資料的增刪改查（CRUD）的動作時，就需要進一步透過網路，向後端伺服器發送請求(也就是串接後端 API)
如何開始用 Vue Router？ 當你已經開了一個 vue 專案後，可以透過以下指令安裝 Vue Router。
vue add router
在安裝的過程中，會出現是否選擇 History Mode 的選項。 若選擇否，則會套用 Hash Mode。這兩種模式的差異，等等會詳細說明，建議先選擇 Hash Mode。
安裝好之後，來觀察看看專案下哪邊變得不同了。
網址多了 # 符號，此處與設定 Hash Mode 有關，詳看頁尾解釋。 網頁最上方多了可以切換路由的導覽列 專案多了 router（使用裡面的 index.js 檔案來設定路由）、views（擺放可以被 index.js 使用的頁面元件。通常一個路由會對應到一個 views 裡面的 component）的資料夾。 如何設定路由？ 讓我們從 router 資料夾裡面的 index.</description>
            <content type="html"><![CDATA[<p>今天想來聊聊 Vue Router。</p>
<p>Vue Router 是由前端實作的路由，有了它，就可以透過前端操控路由，打造一個前端 SPA*。在過往路由需要先經過網路（Internet），並透過後端伺服器，進行請求與回應的動作，才能顯示路由指定的頁面，但是透過 Vue Router，就不一定需要網路與後端，也能渲染這個路由指定的頁面。</p>
<blockquote>
<p>SPA 為 Single-page Application 的簡寫。指的是「不跳頁」的網頁設計原則，例如著名的 Gmail。所以你在用 Gmail 的時候，會感覺好像「在用一個 App」而不是在用「網頁」，因為頁面之間跳轉的很流暢，而不像一般網站一樣在操作過程需要不斷重整頁面。</p>
</blockquote>
<hr>
<p>使用 Vue Router 時，當我們想變更路由，會經過以下的步驟：</p>
<ol>
<li>啟動 Vue Router</li>
<li>藉由 JavaScript 動態更改網址</li>
<li>載入對應的 component</li>
<li>渲染顯示頁面</li>
</ol>
<p>但是當需要使用到資料的增刪改查（CRUD）的動作時，就需要進一步透過網路，向後端伺服器發送請求(也就是串接後端 API)</p>
<h2 id="如何開始用-vue-router">如何開始用 Vue Router？</h2>
<p>當你已經開了一個 vue 專案後，可以透過以下指令安裝 Vue Router。</p>
<p><code>vue add router</code></p>
<p>在安裝的過程中，會出現是否選擇 History Mode 的選項。
若選擇否，則會套用 Hash Mode。這兩種模式的差異，等等會詳細說明，建議先選擇 <strong>Hash Mode</strong>。</p>
<p><img alt="圖片來自 ALPHA Camp" src="https://i.imgur.com/9lRzVkT.png"></p>
<p>安裝好之後，來觀察看看專案下哪邊變得不同了。</p>
<ol>
<li>網址多了 <code>#</code> 符號，此處與設定 Hash Mode 有關，詳看頁尾解釋。</li>
<li>網頁最上方多了可以切換路由的導覽列</li>
<li>專案多了 <strong>router</strong>（使用裡面的 index.js 檔案來設定路由）、<strong>views</strong>（擺放可以被 index.js 使用的頁面元件。通常一個路由會對應到一個 views 裡面的 component）的資料夾。</li>
</ol>
<h2 id="如何設定路由">如何設定路由？</h2>
<p>讓我們從 router 資料夾裡面的 index.js 開始著手。</p>
<p>將這個檔案打開後，可以看到有一個 routes 陣列。裡面可以設定路由，而設定的方法就是寫下 path(網址)、name(路由名稱)、component(對應到的元件名稱)。</p>
<p><img src="https://i.imgur.com/Vyxg5of.png"></p>
<p>這裡你可能會發現到在程式碼中，透過 <code>import</code> 載入 <code>Home</code> 頁面和載入 <code>About</code> 頁面的方式不太一樣，<code>Home.vue</code> 的載入路徑寫在檔案的最上方，這代表 <code>Home.vue</code> 在每次載入路由時，都會一併載入。</p>
<p>而 <code>About.vue</code> 的情況，是把 <code>import</code> 寫在 <code>component</code> 屬性內，在有人到達 <code>/about</code> 這組路由時，才會執行 <code>component</code> 裡的 function，動態載入需要的檔案。這樣的寫法可以減少不必要的流量：如果使用者沒有到達這裡、那就不用預先載入這頁的組件內容。</p>
<p>在 <code>App.vue</code> 這個檔案中的 <code>&lt;router-veiw /&gt;</code> 也就是透過 view-router 渲染之元件所顯示的位置。</p>
<p><code>router-link</code> 的用途則是與 <code>&lt;a herf=””&gt;</code> 標籤有點相似，但是是透過 View Router 去尋找對應連結。</p>
<p><img src="https://i.imgur.com/ScUTUCD.png"></p>
<h2 id="補充hash-mode-和-history-mode">補充：Hash Mode 和 History Mode</h2>
<h3 id="hash-mode">Hash Mode</h3>
<p>使用 Hash Mode 時，當連結有變動，會觸發 <code>onhashchange</code> 事件，vue 就會渲染對應的 component。在此模式下，瀏覽器會向<strong>根目錄</strong>發出請求，再透過 <code>#</code> 分辨不同的路由，且<strong>不會重新載入</strong>。每當改變 <code>#</code> 後面的部分時，會在瀏覽器的訪問歷史中增加紀錄，如此一來我們就可以透過上一頁的按鈕，重返上一頁。</p>
<h3 id="history-mode">History Mode</h3>
<p>使用 History Mode 時，雖然網址不會顯示 <code>#</code> 符號，看起來是常見的網址，但若未對伺服器或 CDN 進行相關的設定，在對外佈署後，就會發生手動變更網址、或是重整頁面時，連到 <code>404</code> 的錯誤頁面。</p>
<h3 id="為什麼會有這種狀況呢">為什麼會有這種狀況呢？</h3>
<p>因為用前端路由做出來的 SPA 網頁只有首頁，其他頁面則是透過 JavaScript 動態渲染。</p>
<p>為了取得 JavaScript 的內容，必須從首頁開始載入。可是在 <code>History Mode</code> 下，Vue 幫我們設定好開發環境，再以 <code>window.history.pushState()</code> 來實現新增歷史紀錄、以及不會重新載入的效果。所以若是脫離 Vue 的開發環境，又沒做額外設定的話，就會發生問題。</p>
]]></content>
        </item>
        
        <item>
            <title>reduce() 是什麼？該如何使用？</title>
            <link>https://jyunyi-lin.github.io/posts/2021/04/reduce-%E6%98%AF%E4%BB%80%E9%BA%BC%E8%A9%B2%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/</link>
            <pubDate>Wed, 07 Apr 2021 15:21:50 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2021/04/reduce-%E6%98%AF%E4%BB%80%E9%BA%BC%E8%A9%B2%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/</guid>
            <description>昨天在面試時突然被問到有沒有使用過 reduce，一時之間腦內跑馬燈走過，有聽過這個字但好像沒有實際使用過，於是模稜兩可的給了一個很爛的回答，讓人後悔至極，應該大方承認自己沒有相關使用經驗，至少還比較有臺階可下。不過也因為如此，讓我發現自己對這個陣列的操作方法還不熟，趕緊來補強一下。
Array.prototype.reduce() 根據 MDN 的說明，reduce 方法將一個累加器及陣列中每項元素（由左至右）傳入回呼函式，將陣列化為單一值。其實這個描述挺寫實的，不過我們搭配實作來看會更清楚。
Syntax array.reduce(function(accumulator, currentValue, currentIndex, array),initialValue) 其中有 4 個參數，分別代表不同的意思。
accumulator：累加總計 currentValue：目前值 currentIndex（optional）：這一輪迭代的索引（index） array（optional）：陣列內容 而 initialValue 則是代表第一次要傳入的初始值。
實例 1 const array = [1, 3, 4, 5] const arrayReduced = array.reduce((accumulator, currentValue) =&amp;gt; { return accumulator + currentValue }, 5) //初始值為 5 console.log(arrayReduced) // 18 No accumulator currentValue currentIndex return value 1 5 1 0 6 2 6 3 1 9 3 9 4 2 13 4 13 5 3 18 可以發現當我們的初始值是 5 的時候，accumulator 就是從 5 開始計算，後面接續 currentValue 的值累計。</description>
            <content type="html"><![CDATA[<p>昨天在面試時突然被問到有沒有使用過 <code>reduce</code>，一時之間腦內跑馬燈走過，有聽過這個字但好像沒有實際使用過，於是模稜兩可的給了一個很爛的回答，讓人後悔至極，應該大方承認自己沒有相關使用經驗，至少還比較有臺階可下。不過也因為如此，讓我發現自己對這個陣列的操作方法還不熟，趕緊來補強一下。</p>
<h2 id="arrayprototypereduce">Array.prototype.reduce()</h2>
<p>根據 MDN 的說明，<code>reduce</code> 方法將一個累加器及陣列中每項元素（由左至右）傳入回呼函式，將陣列化為單一值。其實這個描述挺寫實的，不過我們搭配實作來看會更清楚。</p>
<h3 id="syntax">Syntax</h3>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">array.reduce(function(accumulator, currentValue, currentIndex, array),initialValue)
</code></pre><p>其中有 4 個參數，分別代表不同的意思。</p>
<ul>
<li>accumulator：累加總計</li>
<li>currentValue：目前值</li>
<li>currentIndex（optional）：這一輪迭代的索引（index）</li>
<li>array（optional）：陣列內容</li>
</ul>
<p>而 <code>initialValue</code> 則是代表第一次要傳入的<code>初始值</code>。</p>
<h3 id="實例-1">實例 1</h3>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">const array = [1, 3, 4, 5]
const arrayReduced = array.reduce((accumulator, currentValue) =&gt; {
  return accumulator + currentValue
}, 5)   //初始值為 5

console.log(arrayReduced)  // 18
</code></pre><table>
<thead>
<tr>
<th style="text-align:center">No</th>
<th style="text-align:center">accumulator</th>
<th style="text-align:center">currentValue</th>
<th style="text-align:center">currentIndex</th>
<th style="text-align:center">return value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">9</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">13</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">13</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">18</td>
</tr>
</tbody>
</table>
<p>可以發現當我們的初始值是 5 的時候，<code>accumulator</code> 就是從 5 開始計算，後面接續 <code>currentValue</code> 的值累計。</p>
<h3 id="實例-2">實例 2</h3>
<p>reduce() 也可以用來合併陣列。</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">const array = [[1, 3, 4, 5], [6, 7, 8], [9, 10, 11]]
const arrayReduced = array.reduce((accumulator, currentValue) =&gt; {
  return accumulator.concat(currentValue)
}, [])

console.log(arrayReduced) // [1, 3, 4, 5, 6, 7, 8, 9, 10, 11]
</code></pre><p>或者來計算相同字串的數量並以物件呈現。</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">const array = [&#39;apple&#39;, &#39;orange&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;apple&#39;, &#39;banana&#39;]
const arrayReduced = array.reduce((accumulator, currentValue) =&gt; {
  if (currentValue in accumulator) {
    accumulator[currentValue]++
  } else {
    accumulator[currentValue] = 1
  }
  return accumulator
}, {})

console.log(arrayReduced) // {apple: 3, orange: 2, banana: 1}
</code></pre><p><code>reduce</code> 的 <code>initialValue</code> 可以設為任一型態（數值、物件、陣列），而 <code>accumulator</code> 可繼承 <code>initialValue</code> 的型態並接收 <code>currentValue</code> 計算後的結果。</p>
<h2 id="結論">結論</h2>
<ul>
<li>使用 <code>reduce</code> 可以進行比較細膩的比對與操作，尤其在陣列的 item 與 item 之間。</li>
<li>執行前記得確認 <code>initialValue</code>，因為他會決定累加器的初始值，影響 return 的結果。</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>ALPHA Camp 畢業心得</title>
            <link>https://jyunyi-lin.github.io/posts/2021/04/alpha-camp-%E7%95%A2%E6%A5%AD%E5%BF%83%E5%BE%97/</link>
            <pubDate>Thu, 01 Apr 2021 15:29:24 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2021/04/alpha-camp-%E7%95%A2%E6%A5%AD%E5%BF%83%E5%BE%97/</guid>
            <description>從 2020 年 9 月一直到現在，整整半年的時間，終於是寫畢業部落格的時機了。還記得剛開始接觸 JavaScript 時笨拙得連函式都搞不太清楚，物件跟陣列分不出個所以然的自己。一路走來真是有種浴火重生，現在才要開始的感慨。完全沒有後悔過這個選擇，因為不論上完課程後是否要轉職，過程中所得到的收穫是比這個結果還要更重要、更能影響我的。
還記得一開始寫 AC 要求的技術文章時，覺得有點麻煩之外，又想說怎麼會有人來看呢，滿心都是一個想逃避的態度。後來寫著寫著不知為何就啟動某個開關，其實根本不需要真的有人來閱讀，只要我還有在讀自己的文章，這些被記錄下的事就是有價值的。現在很感謝 AC 的這種作業形式，讓我更能反覆的反省、思考不足之處。
我想大略談談每個學期的感受，雖然之前已經有兩篇學期心得文，還是不厭煩的來總結一下。
2-1 剛開始接觸 JavaScript，即使稍微有點 HTML，CSS 的觀念，還是很難應付這個全新的東西。好像在新手村還沒辦法轉職的初心者，只能默默打怪，然後等待出頭天的時候來臨。
2-2 終於可以轉職了，進入前端世界，學習新技能：DOM 與 Ajax。學了新技能後好像發現新世界，自己居然可以靠著簡單的語法完成一個簡單的社群名單還有翻牌遊戲，讓人大開眼界。
2-3 由淺入深的後端世界。這時已經可以自己單打獨鬥，但還是會因為一時的疏忽而跑出墓碑。最讓人有成就感的就是終於可以把自己的作品跟別人分享了，部署技能 get。還學了一些護身法術，像是 git 之類的。
3 巫師的磨練。這關是要與同伴並肩作戰打敗 Simple Twitter 魔王的。俗話說的好，三個臭皮匠，勝過一個諸葛亮。在組隊加持下，即使途中遭遇無數次困難，也都能扭轉乾坤，順利過關。
大概就是這樣的感覺了。學期三作為最後一個學期，其內容之縝密、任務之精實。任務結束後的各種反思主題讓人印象深刻，就是透過這樣不斷地內化，才能打造更堅強不可摧的心靈。做好一件事，不只是表面上看起來完成，裡面也要結實纍纍，這樣才禁得起未來的困難。這是對我來說感受最深的一課。
即使課程告一段落了，但人生的旅程才正要開始，繼續學習新技能，穩扎穩打，目標不是有一天能單挑大魔王，而是能與一群夥伴一起走過一個充實的人生。</description>
            <content type="html"><![CDATA[<p>從 2020 年 9 月一直到現在，整整半年的時間，終於是寫畢業部落格的時機了。還記得剛開始接觸 JavaScript 時笨拙得連函式都搞不太清楚，物件跟陣列分不出個所以然的自己。一路走來真是有種浴火重生，現在才要開始的感慨。完全沒有後悔過這個選擇，因為不論上完課程後是否要轉職，過程中所得到的收穫是比這個結果還要更重要、更能影響我的。</p>
<p>還記得一開始寫 AC 要求的技術文章時，覺得有點麻煩之外，又想說怎麼會有人來看呢，滿心都是一個想逃避的態度。後來寫著寫著不知為何就啟動某個開關，其實根本不需要真的有人來閱讀，只要我還有在讀自己的文章，這些被記錄下的事就是有價值的。現在很感謝 AC 的這種作業形式，讓我更能反覆的反省、思考不足之處。</p>
<p>我想大略談談每個學期的感受，雖然之前已經有兩篇學期心得文，還是不厭煩的來總結一下。</p>
<hr>
<h3 id="2-1">2-1</h3>
<p>剛開始接觸 JavaScript，即使稍微有點 HTML，CSS 的觀念，還是很難應付這個全新的東西。好像在新手村還沒辦法轉職的初心者，只能默默打怪，然後等待出頭天的時候來臨。</p>
<h3 id="2-2">2-2</h3>
<p>終於可以轉職了，進入前端世界，學習新技能：DOM 與 Ajax。學了新技能後好像發現新世界，自己居然可以靠著簡單的語法完成一個簡單的社群名單還有翻牌遊戲，讓人大開眼界。</p>
<h3 id="2-3">2-3</h3>
<p>由淺入深的後端世界。這時已經可以自己單打獨鬥，但還是會因為一時的疏忽而跑出墓碑。最讓人有成就感的就是終於可以把自己的作品跟別人分享了，部署技能 get。還學了一些護身法術，像是 git 之類的。</p>
<h3 id="3">3</h3>
<p>巫師的磨練。這關是要與同伴並肩作戰打敗 Simple Twitter 魔王的。俗話說的好，三個臭皮匠，勝過一個諸葛亮。在組隊加持下，即使途中遭遇無數次困難，也都能扭轉乾坤，順利過關。</p>
<hr>
<p>大概就是這樣的感覺了。學期三作為最後一個學期，其內容之縝密、任務之精實。任務結束後的各種反思主題讓人印象深刻，就是透過這樣不斷地內化，才能打造更堅強不可摧的心靈。做好一件事，不只是表面上看起來完成，裡面也要結實纍纍，這樣才禁得起未來的困難。這是對我來說感受最深的一課。</p>
<p>即使課程告一段落了，但人生的旅程才正要開始，繼續學習新技能，穩扎穩打，目標不是有一天能單挑大魔王，而是能與一群夥伴一起走過一個充實的人生。</p>
]]></content>
        </item>
        
        <item>
            <title>Vue.js 學習筆記 - 2</title>
            <link>https://jyunyi-lin.github.io/posts/2021/04/vue.js-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-2/</link>
            <pubDate>Thu, 01 Apr 2021 14:37:32 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2021/04/vue.js-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-2/</guid>
            <description>這次跟著複習的腳步，再來看看 Vue 常用的指令吧！如果是第一次來的朋友，歡迎先去看看第一篇簡介 Vue 框架的文章喔。
常用指令 v-on 事件監聽 使用 DOM API 監聽事件的時候，會需要先把要觸發事件的節點設定出來，再用 addEventListener() 來做監聽。在 Vue 裡面只需要將 v-on 寫在想觸發事件的 HTML 標籤上，就可以進行事件監聽。
使用方法為：v-on:事件動作=&amp;quot;事件動作執行後要用的 method&amp;quot; 可以簡寫為：@事件動作=&amp;quot;事件動作執行後要用的 method&amp;quot;
假設我們想在點擊按鈕後觸發瀏覽器提醒，可以這樣寫：
&amp;lt;button v-on:click=&amp;#34;alertAfterClick&amp;#34;&amp;gt;點擊按鈕&amp;lt;/button&amp;gt; 或者使用簡寫：
&amp;lt;button @click=&amp;#34;alertAfterClick&amp;#34;&amp;gt;點擊按鈕&amp;lt;/button&amp;gt; 觸發事件後會執行的方法寫在 method 裡面：
methods: { alertAfterClick () { window.alert(&amp;#39;點擊到按鈕了&amp;#39;) } } 如此一來視窗就會順利出現相對應得 Alert 囉！
v-bind 想增加 HTML 屬性值或把父元件的資料帶入子元件時就可以使用 v-bind。
使用方法為：v-bind: 屬性名稱或要被使用之資料現在使用時要用的名稱=&amp;quot;屬性值(主要會用 true 和 false 操控)或資料名稱&amp;quot; 可以簡寫為：:屬性名稱或要被使用之資料現在使用時要用的名稱=&amp;quot;屬性值(主要會用 true 和 false 操控)或資料名稱&amp;quot;
直接來看看例子吧，我們將 img 標籤綁定了使用者的 ID 與大頭貼照片：
&amp;lt;img v-bind:src=&amp;#34;user.avatar&amp;#34; v-bind:data-id=&amp;#34;user.id&amp;#34; &amp;gt; 或者使用簡寫：</description>
            <content type="html"><![CDATA[<p>這次跟著複習的腳步，再來看看 Vue 常用的指令吧！如果是第一次來的朋友，歡迎先去看看第一篇簡介 Vue 框架的<a href="https://chuni-lin.github.io/posts/2021/03/vue.js-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-1/">文章</a>喔。</p>
<h2 id="常用指令">常用指令</h2>
<h3 id="v-on-事件監聽">v-on 事件監聽</h3>
<p>使用 DOM API 監聽事件的時候，會需要先把要觸發事件的節點設定出來，再用 addEventListener() 來做監聽。在 Vue 裡面只需要將 v-on 寫在想觸發事件的 HTML 標籤上，就可以進行事件監聽。</p>
<p>使用方法為：<code>v-on:事件動作=&quot;事件動作執行後要用的 method&quot;</code>
可以簡寫為：<code>@事件動作=&quot;事件動作執行後要用的 method&quot;</code></p>
<p>假設我們想在點擊按鈕後觸發瀏覽器提醒，可以這樣寫：</p>
<pre tabindex="0"><code class="language-html=" data-lang="html=">&lt;button v-on:click=&#34;alertAfterClick&#34;&gt;點擊按鈕&lt;/button&gt;
</code></pre><p>或者使用簡寫：</p>
<pre tabindex="0"><code class="language-html=" data-lang="html=">&lt;button @click=&#34;alertAfterClick&#34;&gt;點擊按鈕&lt;/button&gt;
</code></pre><p>觸發事件後會執行的方法寫在 method 裡面：</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">methods: {
    alertAfterClick () {
      window.alert(&#39;點擊到按鈕了&#39;)
    }
}
</code></pre><p>如此一來視窗就會順利出現相對應得 Alert 囉！</p>
<h3 id="v-bind">v-bind</h3>
<p>想增加 HTML 屬性值或把父元件的資料帶入子元件時就可以使用 v-bind。</p>
<p>使用方法為：<code>v-bind: 屬性名稱或要被使用之資料現在使用時要用的名稱=&quot;屬性值(主要會用 true 和 false 操控)或資料名稱&quot;</code>
可以簡寫為：<code>:屬性名稱或要被使用之資料現在使用時要用的名稱=&quot;屬性值(主要會用 true 和 false 操控)或資料名稱&quot;</code></p>
<p>直接來看看例子吧，我們將 img 標籤綁定了使用者的 ID 與大頭貼照片：</p>
<pre tabindex="0"><code class="language-html=" data-lang="html=">&lt;img
  v-bind:src=&#34;user.avatar&#34;
  v-bind:data-id=&#34;user.id&#34;
&gt;
</code></pre><p>或者使用簡寫：</p>
<pre tabindex="0"><code class="language-html=" data-lang="html=">&lt;img
  :src=&#34;user.avatar&#34;
  :data-id=&#34;user.id&#34;
&gt;
</code></pre><p>大功告成！</p>
<h3 id="v-for-迴圈">v-for 迴圈</h3>
<p>在 Vue 框架中當然也有迴圈來渲染資料，可以將陣列資料依序渲染到 HTML 裡面，只需要一組固定的 HTML，不需要像操控 DOM 一樣，還要額外插入 HTML。</p>
<p>使用方法為：<code>v-for=&quot;(item, index) in items&quot; 加上 :key=&quot;item.id&quot;</code></p>
<blockquote>
<p>加上 key 的原因是因為 Vue 會用 key 值判斷資料有無被修改，有 key 值的時候，在渲染資料時，就可以避免因為資料所造成的渲染問題。</p>
</blockquote>
<p>看看範例怎麼寫：</p>
<pre tabindex="0"><code class="language-html=" data-lang="html=">&lt;UserList
  v-for=&#34;user in users&#34;
  :key=&#34;user.id&#34;
  :user=&#34;user&#34;
  @afterToggleFollow=&#34;afterToggleFollow&#34;
/&gt;
</code></pre><p>我們在 UserList 這個 component 傳入 user 的迴圈，同時綁定 key 值，這樣設定後，就會依照資料數量來渲染 user 的卡片數。</p>
<h3 id="v-model-雙向綁定">v-model 雙向綁定</h3>
<p>雙向綁定可以讓我們在操作資料時更方便與彈性，如果沒有將資料雙向綁定，就只能單方面地從後端資料庫更改內容，但要是做了雙向綁定，當使用者在輸入時也能一定更改資料內容喔！可以想成是你在更改帳號名稱的時候，我們就會做雙向綁定來取得你的新名稱。</p>
<p>使用方法為：<code>v-model=&quot;要綁定的資料&quot;</code></p>
<p>範例：</p>
<pre tabindex="0"><code class="language-html=" data-lang="html=">&lt;input v-model=&#34;search&#34;&gt;
</code></pre><p>我們在 input 上做資料的雙向綁定是為了要取得使用者想查詢的內容是什麼，如此才能使用這個內容再撈資料回傳給使用者。</p>
<h3 id="v-if-v-else-v-else-if-條件設定">v-if, v-else, v-else-if 條件設定</h3>
<p>這個條件是判斷就跟 JavaScript 中的一樣，設定一個條件，來決定是否渲染這部分的 HTML。如果為 true，就會出現 HTML；如果為 false，就不渲染 HTML</p>
<p>使用方法為：<code>v-if=&quot;條件內容&quot;，可以搭配 v-else 使用，若多條件則再加 v-else-if</code></p>
<p>範例：</p>
<pre tabindex="0"><code class="language-html=" data-lang="html=">&lt;template v-if=&#34;mode === &#39;card&#39;&#34;&gt;
  &lt;UserCard
    v-for=&#34;(user, index) in users&#34;
    :key=&#34;user.id&#34;
    :user=&#34;user&#34;
  /&gt;
&lt;/template&gt;

&lt;template v-else&gt;
  &lt;UserList
    v-for=&#34;user in users&#34;
    :key=&#34;user.id&#34;
    :user=&#34;user&#34;
  /&gt;
 &lt;/template&gt;
</code></pre><p>當現在的 mode 是卡片時則顯示 UserCard 的元件；否則顯示 UserList。</p>
<h3 id="v-show">v-show</h3>
<p>跟 v-if 很像，都可以用 true 和 false 來控制是否顯示指定部分的內容，不同的地方是，v-if 會決定是否渲染，而 v-show 不管是 true 還是 false 都會渲染出來，只是會用 CSS hidden 讓這部分被隱藏，所以從開發者工具查看的話，不管是 true 還是 false 的 HTML 都會被顯示在上面。</p>
<p>使用方法為：<code>v-show=&quot;條件內容&quot;</code></p>
<pre tabindex="0"><code class="language-html=" data-lang="html=">&lt;template v-show=&#34;mode === &#39;card&#39;&#34;&gt;
  &lt;UserCard
    v-for=&#34;(user, index) in users&#34;
    :key=&#34;user.id&#34;
    :user=&#34;user&#34;
  /&gt;
&lt;/template&gt;
</code></pre><p>當 mode 是 card 時會被渲染在畫面上，但即使不等於時這一段 HTML 也會在開發者工具出現，只是會被設定 <code>display: none</code>。</p>
<h2 id="休息一下吧">休息一下吧</h2>
<p>這次指令就複習到這邊，是不是有種躍躍欲試的感覺呢？快把新學到的把手玩一玩吧!</p>
]]></content>
        </item>
        
        <item>
            <title>Vue.js 學習筆記 - 1</title>
            <link>https://jyunyi-lin.github.io/posts/2021/03/vue.js-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-1/</link>
            <pubDate>Wed, 31 Mar 2021 09:58:16 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2021/03/vue.js-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-1/</guid>
            <description>學了 Vue 也已經一段時間，實作了餐廳論壇與簡易的社交平台後，發現還有許多陌生的地方。趁著記憶還猶新，一邊複習，一邊把知識補足起來。對 Vue 有興趣的人也可以跟著複習的腳步，稍微認識一下這個框架是什麼、如何使用。前情提要：由於是複習文章，可能不會有太詳細的教學，如果讀了之後發現還未懂透的話，建議可以搭配 Vue 官方文件來服用，效果更佳。
Vue 是什麼？ Vue 是一個前端框架。隨著這幾年前後端分離，前端框架如雨後春筍般冒出，形成 React、Vue、Angular 三大局面。其中 React 是比較難學習的，而 Vue 則是最好上手。前端框架很多樣，但基本上都面對以下三件事：❶ 渲染局部頁面、❷ 網頁元件化，使用邏輯控制組件、❸ 處理 URL 與資料流。
Vue 可以讓 HTML、CSS 這些與畫面相關的部分與 JavaScript 分開管理，且能以資料操控畫面，整體上的效能顯得更好。
初始設置 在使用 Vue 之前，我們需要先 ❶ 安裝 Vue，接著 ❷ 創建一個新專案，然後 ❸ 啟動這個專案。
npm install -g @vue/cli //在全域環境安裝 vue create your-project-name npm run server 完成後，打開你的 code editor，進入這個專案中，會看到幾個資料夾。
資料夾詳解 public 資料夾 這個資料夾裡會有網頁的 icon 和 index.html 檔案，html 檔案主要是 Vue 預設的一些內容。通常在專案裡，叫做 public 的資料夾是放一些可以直接被外部讀取到的檔案。
src 資料夾 其中有四個部分，分別是
assets：中文是資產的意思，顧名思義就是放置靜態檔案，如 icon、圖檔、css 設定檔。 components：這個資料夾會放一些元件檔案，使用時，透過 import 引入使用。 main.</description>
            <content type="html"><![CDATA[<p>學了 Vue 也已經一段時間，實作了<a href="https://github.com/chuni-lin/forum-front-end-vue">餐廳論壇</a>與簡易的<a href="https://github.com/chuni-lin/user-list-vue">社交平台</a>後，發現還有許多陌生的地方。趁著記憶還猶新，一邊複習，一邊把知識補足起來。對 Vue 有興趣的人也可以跟著複習的腳步，稍微認識一下這個框架是什麼、如何使用。前情提要：<strong>由於是複習文章，可能不會有太詳細的教學，如果讀了之後發現還未懂透的話，建議可以搭配 <a href="https://vuejs.org/v2/guide/">Vue 官方文件</a>來服用，效果更佳。</strong></p>
<h2 id="vue-是什麼">Vue 是什麼？</h2>
<p><img src="https://i.imgur.com/RJAI2TQ.png"></p>
<p>Vue 是一個前端框架。隨著這幾年前後端分離，前端框架如雨後春筍般冒出，形成 React、Vue、Angular 三大局面。其中 React 是比較難學習的，而 Vue 則是最好上手。前端框架很多樣，但基本上都面對以下三件事：❶ 渲染局部頁面、❷ 網頁元件化，使用邏輯控制組件、❸ 處理 URL 與資料流。</p>
<p>Vue 可以讓 HTML、CSS 這些與畫面相關的部分與 JavaScript 分開管理，且能以資料操控畫面，整體上的效能顯得更好。</p>
<h2 id="初始設置">初始設置</h2>
<p>在使用 Vue 之前，我們需要先 ❶ 安裝 Vue，接著 ❷ 創建一個新專案，然後 ❸ 啟動這個專案。</p>
<ol>
<li><code>npm install -g @vue/cli //在全域環境安裝</code></li>
<li><code>vue create your-project-name</code></li>
<li><code>npm run server</code></li>
</ol>
<p>完成後，打開你的 code editor，進入這個專案中，會看到幾個資料夾。</p>
<h2 id="資料夾詳解">資料夾詳解</h2>
<h3 id="public-資料夾">public 資料夾</h3>
<p>這個資料夾裡會有網頁的 <code>icon</code> 和 <code>index.html</code> 檔案，<code>html</code> 檔案主要是 <code>Vue</code> 預設的一些內容。通常在專案裡，叫做 <code>public</code> 的資料夾是放一些可以直接被外部讀取到的檔案。</p>
<h3 id="src-資料夾">src 資料夾</h3>
<p>其中有四個部分，分別是</p>
<ol>
<li>assets：中文是資產的意思，顧名思義就是放置靜態檔案，如 <code>icon</code>、圖檔、<code>css</code> 設定檔。</li>
<li>components：這個資料夾會放一些元件檔案，使用時，透過 import 引入使用。</li>
<li>main.js：這是 JavaScript 的進入點。<code>vue</code> 是 Vue.js 本身，<code>App.vue</code> 是整個專案本身。最底下的 <code>$mount('#app')</code> ，這個動作會把所有和 Vue 有關的內容都放進 public/index.html 裡的 <code>&lt;div id=&quot;app&quot;&gt;</code>。<img src="https://i.imgur.com/E5nkH8n.png"></li>
<li>App.vue：這個檔案裡又分為三個大部分，分別是 template、script、style。
&ndash; <code>&lt;template&gt;&lt;/template&gt;</code> 裡放 HTML 元素內容
&ndash; <code>&lt;script&gt;&lt;/script&gt;</code> 內放 JavaScript 語法，大多是和 Vue 有關的資料處理
&ndash; <code>&lt;style&gt;&lt;/style&gt;</code> 裡則是和 <code>css</code> 樣式相關的設定</li>
</ol>
<p>App.vue 中的設定都會套用到整個專案，可以把它想成是一個主元件。實際進行時還會再另外分出其他元件，像是一個路由會對到一個頁面的父元件和可以被多個父元件共用的子元件。 *<em>在 Vue 預設的內容中，引入的子元件是 <code>HelloWorld</code></em></p>
<h2 id="專案建構完成">專案建構完成</h2>
<p>完成第一步的專案建構與認識 Vue 構造。下一回我想繼續複習 Vue 的指令部分。</p>
]]></content>
        </item>
        
        <item>
            <title>使用 FileReader 實現圖片預覽</title>
            <link>https://jyunyi-lin.github.io/posts/2021/03/%E4%BD%BF%E7%94%A8-filereader-%E5%AF%A6%E7%8F%BE%E5%9C%96%E7%89%87%E9%A0%90%E8%A6%BD/</link>
            <pubDate>Tue, 30 Mar 2021 15:11:54 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2021/03/%E4%BD%BF%E7%94%A8-filereader-%E5%AF%A6%E7%8F%BE%E5%9C%96%E7%89%87%E9%A0%90%E8%A6%BD/</guid>
            <description>使用 FileReader 實現圖片預覽 如何讓使用者在更換大頭貼或者封面照時能即時看到更換後的預覽圖呢？我們可以使用 FileReader 來實現。FileReader 是一種 web API，藉由 FileReader 物件，Web 應用程式能以非同步（asynchronously）方式讀取儲存在用戶端的檔案（或原始資料暫存）內容。
實作 首先要先創建 FileReader 的對象實例 然後設定在 onload 時要做什麼事 最後讀取指定的 Blob，讀取完成後 result 將以 data: URL 格式（base64 編碼）的字串來表示讀入的資料內容。Blob 是 Binary Large Object 的縮寫，它是一個物件，該物件代表了一個相當於原始資料的不可變物件。 const reader = new FileReader() //創建 FileReader 的對象實例 reader.onload = (event) =&amp;gt; { //設定 onload handler if (input.id === &amp;#39;cover&amp;#39;) { coverPreview.src = `${event.target.result}` } if (input.id === &amp;#39;avatar&amp;#39;) { avatarPreview.src = `${event.target.result}` } } reader.readAsDataURL(input.files[0]) //讀取完成後以 data: URL 格式的字串來表示讀入的資料內容 Error!</description>
            <content type="html"><![CDATA[<h1 id="使用-filereader-實現圖片預覽">使用 FileReader 實現圖片預覽</h1>
<p>如何讓使用者在更換大頭貼或者封面照時能即時看到更換後的預覽圖呢？我們可以使用 FileReader 來實現。FileReader 是一種 web API，藉由 FileReader 物件，Web 應用程式能以非同步（asynchronously）方式讀取儲存在用戶端的檔案（或原始資料暫存）內容。</p>
<h2 id="實作">實作</h2>
<ol>
<li>首先要先創建 FileReader 的對象實例</li>
<li>然後設定在 onload 時要做什麼事</li>
<li>最後讀取指定的 Blob，讀取完成後 result 將以 data: URL 格式（base64 編碼）的字串來表示讀入的資料內容。Blob 是 Binary Large Object 的縮寫，它是一個物件，該物件代表了一個相當於原始資料的不可變物件。</li>
</ol>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">  const reader = new FileReader()  //創建 FileReader 的對象實例
    reader.onload = (event) =&gt; {   //設定 onload handler
      if (input.id === &#39;cover&#39;) {
        coverPreview.src = `${event.target.result}`
      }
      if (input.id === &#39;avatar&#39;) {
        avatarPreview.src = `${event.target.result}`
      }
    }
    reader.readAsDataURL(input.files[0]) //讀取完成後以 data: URL 格式的字串來表示讀入的資料內容
</code></pre><h2 id="error">Error!</h2>
<p>操作到這邊，功能皆正常，但檢查器卻出現一個 error 說 FileReader is not defined。
<img src="https://i.imgur.com/Cyh2tVg.png"></p>
<h2 id="解決方法">解決方法</h2>
<p>試了很多方法後，發現在 stake overflow 上已經有人提出一樣的疑問。原來問題就出在我們沒指出要在哪裡使用 FileReader。error 會出現是因為 webpack 無法在 Node.js 中找到 FileReader，但我們是要在瀏覽器裡使用 FileReader 實現預覽功能，所以只要加上 window 就可以了：</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">const reader = new window.FileReader()  //我們是要在瀏覽器中使用 FileReader
</code></pre><p>🥳 恭喜完成預覽功能！</p>
]]></content>
        </item>
        
        <item>
            <title>Simple Twitter self-reflection</title>
            <link>https://jyunyi-lin.github.io/posts/2021/03/simple-twitter-self-reflection/</link>
            <pubDate>Thu, 18 Mar 2021 22:36:28 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2021/03/simple-twitter-self-reflection/</guid>
            <description>兩個禮拜的開發過程一下就過了。期間經歷了團隊合作、自動化測試 Debug、尋找技術文件、協作開發遇到的各種 git 問題等，讓人成長許多。凡走過必留下痕跡，這篇文章便是希望能寫下一些開發時遇到的插曲，留給以後的自己回味外，或許在之後遇到問題後也能回首來尋找答案。
專案介紹 ALPHA Camp 的畢業專案是復刻一個 Twitter 功能的 Web Application。協作能以全端或前後端分離來進行，全端是在 Node.js 上以 JavaScript 為主要語言、Handlebars 為前端模板來進行，採用 MySQL 作為資料庫，使用 Sequelize 操作資料庫。專案完成後部署至 Heroku；前後端分離則是後端製作 API，前端以 Vue.js 做開發。我們這一組選擇全端開發。
開發流程 專案開始後，組長先在 trello 上建立功能看板，組員則自己選擇樣板來開發。不過，主要的模板，例如資料庫、model 建立、登入登出等專案基礎架構由組長先完成。
負責項目 我主要負責種子資料的設計、使用者相關功能如更改個人資訊、個人 Twitter 的頁面等的路由及前端頁面。
開發紀錄 種子資料 專案有設定好必須要有的種子資料，像是用戶有分為一般使用者與管理者，在設計時為了簡化程式，使用了條件（三元）運算子來取代 if&amp;hellip;else，除了更簡潔之外，也佔用較少的行數而讓閱讀更容易。
使用者功能 主要實作諸如取得使用者頁面、使用者回覆紀錄、使用者按讚紀錄、使用者資訊修改等功能與頁面。其中遇到比較大的問題是，題目規定使用者的關注清單，排序依照追蹤紀錄成立的時間，愈新的在愈前面，一開始以 sequelize 的 order 來做，試了好幾次都無法成功，最後參考此篇文章中以 Array 的 sort() 方法成功解決。
results.Followers.sort((a, b) =&amp;gt; b.Followship.createdAt - a.Followship.createdAt) 團隊協作 三個人開發與一個人開發的過程截然不同。這也顯現了溝通的重要性。畢竟有些容易重疊的功能，或者是相互依賴的功能（沒有你就沒有我），這時候就會出現「如果隊友沒有完成某一功能，我這邊也無法測試」的狀況。又或者是發 PR 後出現 conflict，就要討論如何保留取捨。同時，我也深刻理解到 git commit message 的重要性，如何讓人看到 commit 就一目了然這是實作什麼功能在開發時間有限的專案中非常關鍵，畢竟一分一秒都彌足珍貴。幸好隊友都非常給力，組長也幾乎是有問必答，整體算是順利。
收穫與學習 最大的收穫就是理解到自己不論是在技術層面或是溝通上都還有許多可以學習的地方。在開發過程中我們遇到許多自動化測試未過，但本地功能卻正常的問題，一直到尾聲我們才驚覺根本是自己沒看清楚自動化測試中定義好的規格，深刻體會到細節就藏在魔鬼中這句話的真理。同時，也在團隊協作中意識到如何更能引導隊友、更激勵團隊士氣的方法，我想在往後的職涯是非常有幫助的。寫 code 中最難能可貴的，與其說是專研與通透各項技術，我倒認為是一群志同道合、互助學習的好夥伴。</description>
            <content type="html"><![CDATA[<p><img src="https://i.imgur.com/qceJAv4.jpg"></p>
<p>兩個禮拜的開發過程一下就過了。期間經歷了團隊合作、自動化測試 Debug、尋找技術文件、協作開發遇到的各種 git 問題等，讓人成長許多。凡走過必留下痕跡，這篇文章便是希望能寫下一些開發時遇到的插曲，留給以後的自己回味外，或許在之後遇到問題後也能回首來尋找答案。</p>
<h2 id="專案介紹">專案介紹</h2>
<p>ALPHA Camp 的畢業專案是復刻一個 Twitter 功能的 Web Application。協作能以全端或前後端分離來進行，全端是在 Node.js 上以 JavaScript 為主要語言、Handlebars 為前端模板來進行，採用 MySQL 作為資料庫，使用 Sequelize 操作資料庫。專案完成後部署至 Heroku；前後端分離則是後端製作 API，前端以 Vue.js 做開發。我們這一組選擇全端開發。</p>
<h3 id="開發流程">開發流程</h3>
<p>專案開始後，組長先在 trello 上建立功能看板，組員則自己選擇樣板來開發。不過，主要的模板，例如資料庫、model 建立、登入登出等專案基礎架構由組長先完成。</p>
<h3 id="負責項目">負責項目</h3>
<p>我主要負責種子資料的設計、使用者相關功能如更改個人資訊、個人 Twitter 的頁面等的路由及前端頁面。</p>
<h2 id="開發紀錄">開發紀錄</h2>
<h3 id="種子資料">種子資料</h3>
<p>專案有設定好必須要有的種子資料，像是用戶有分為一般使用者與管理者，在設計時為了簡化程式，使用了條件（三元）運算子來取代 if&hellip;else，除了更簡潔之外，也佔用較少的行數而讓閱讀更容易。</p>
<h3 id="使用者功能">使用者功能</h3>
<p>主要實作諸如取得使用者頁面、使用者回覆紀錄、使用者按讚紀錄、使用者資訊修改等功能與頁面。其中遇到比較大的問題是，題目規定使用者的關注清單，排序依照追蹤紀錄成立的時間，愈新的在愈前面，一開始以 sequelize 的 order 來做，試了好幾次都無法成功，最後參考<a href="https://realdennis.medium.com/javascript-%E5%BE%9Earray%E7%9A%84sort%E6%96%B9%E6%B3%95-%E8%81%8A%E5%88%B0%E5%90%84%E5%AE%B6%E7%80%8F%E8%A6%BD%E5%99%A8%E7%9A%84%E5%AF%A6%E4%BD%9C%E7%AE%97%E6%B3%95-c23a335b1b80">此篇文章</a>中以 Array 的 sort() 方法成功解決。</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">results.Followers.sort((a, b) =&gt; b.Followship.createdAt - a.Followship.createdAt)
</code></pre><h3 id="團隊協作">團隊協作</h3>
<p>三個人開發與一個人開發的過程截然不同。這也顯現了溝通的重要性。畢竟有些容易重疊的功能，或者是相互依賴的功能（沒有你就沒有我），這時候就會出現「如果隊友沒有完成某一功能，我這邊也無法測試」的狀況。又或者是發 PR 後出現 conflict，就要討論如何保留取捨。同時，我也深刻理解到 <a href="https://wadehuanglearning.blogspot.com/2019/05/commit-commit-commit-why-what-commit.html">git commit message</a> 的重要性，如何讓人看到 commit 就一目了然這是實作什麼功能在開發時間有限的專案中非常關鍵，畢竟一分一秒都彌足珍貴。幸好隊友都非常給力，組長也幾乎是有問必答，整體算是順利。</p>
<h2 id="收穫與學習">收穫與學習</h2>
<p>最大的收穫就是理解到自己不論是在技術層面或是溝通上都還有許多可以學習的地方。在開發過程中我們遇到許多自動化測試未過，但本地功能卻正常的問題，一直到尾聲我們才驚覺根本是自己沒看清楚自動化測試中定義好的規格，深刻體會到細節就藏在魔鬼中這句話的真理。同時，也在團隊協作中意識到如何更能引導隊友、更激勵團隊士氣的方法，我想在往後的職涯是非常有幫助的。寫 code 中最難能可貴的，與其說是專研與通透各項技術，我倒認為是一群志同道合、互助學習的好夥伴。</p>
]]></content>
        </item>
        
        <item>
            <title>全端產品專案介紹——記帳本</title>
            <link>https://jyunyi-lin.github.io/posts/2021/01/%E5%85%A8%E7%AB%AF%E7%94%A2%E5%93%81%E5%B0%88%E6%A1%88%E4%BB%8B%E7%B4%B9%E8%A8%98%E5%B8%B3%E6%9C%AC/</link>
            <pubDate>Wed, 20 Jan 2021 10:00:33 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2021/01/%E5%85%A8%E7%AB%AF%E7%94%A2%E5%93%81%E5%B0%88%E6%A1%88%E4%BB%8B%E7%B4%B9%E8%A8%98%E5%B8%B3%E6%9C%AC/</guid>
            <description>全端產品專案介紹——記帳本 這是一個提供記帳功能的網路軟體，使用者可以計入自己的開支。除了傳統的註冊之外，也提供 Facebook 登入功能，讓註冊認證程序更容易。登入後，首頁有搜尋、類別篩選、月份篩選、明細及總消費金額的顯示功能。
以下介紹將以循序漸進的方式，藉由起承轉合來講述開發的過程與從中所學之經驗、技術。作品詳細資訊：
GitHub Heroku 為何會選擇這個專案？ 日常所需 這幾年興起的記帳風潮，除了手機 app 的蓬勃發展所帶動之外，大環境經濟因素也使得人不得不好好控管支出，免得當月光族。記帳，不只能將花費具體地呈現，還能培養一種「持續」的能力，在這個瞬息萬變的社會，持之以恆逐漸變得困難，但我們卻可以從日常小事來加以鍛鍊。無論從哪個方面看來，記帳這件事都具有許多益處，而使用一個自己親手打造、磨練的網路帳本，又更增加使用的意願。
商業考量 記帳本屬於使用頻率非常高的網路軟體，加上現在社會傾向一種「個人化」，也就是大家保有相當程度的自我空間、自由，所以這類自我管理用的軟體更有機會受到青睞。為自己負責，是一種安全感最大化的表現。可以大膽假設這是一個在當前，即使是在未來更深入的數位時代，都非常具有潛力及前瞻性的產品。
技能鍛鍊 此專案是以 Node.js 的 Express 框架為基礎所製作的全端產品，對於伺服器的概念及應用、RESTful API 的操作、CRUD 資料操作、使用者驗證等都能有深入淺出的認識，很適合鍛鍊全端開發的基礎能力。除此之外，也訓練了查資料、閱讀資料的關鍵能力。
使用了什麼技術？ 前端技術 BootStrap &amp;amp; RWD Font Awesome 後端技術 網路伺服器 Node.js： JavaScript 執行環境 Express：伺服器框架 npm packages bcryptjs：密碼雜湊加密 body-parser：取得表單（form）資訊 connect-flash：訊息提示 dotenv：管理敏感資訊與環境變數 express-handlebars：樣板引擎(template engine) express-session：儲存認證結果，保留使用者登入狀態 handlebars-helpers：樣版引擎輔助 method-override：RESTful 路由 passport : 根據 session 資訊，驗證使用者 passport-facebook、passport-local：本地與第三方登入機制 資料庫 MongoDB &amp;amp; Mongoose： NoSQL Database &amp;amp; ODM 資料庫 Data Schema 資料設計 CRUD 操作 部署 Heroku 協作技術 Git 版控 GitHub 哪部分你相對能掌握？ 基本的 CRUD 開發、路由大綱與建構、樣版引擎的使用、使用者認證功能及伺服器與資料庫架設是相對比較容易理解與操作的部分。</description>
            <content type="html"><![CDATA[<h1 id="全端產品專案介紹記帳本">全端產品專案介紹——記帳本</h1>
<p><img src="https://i.imgur.com/T44x5kK.png"></p>
<p>這是一個提供記帳功能的網路軟體，使用者可以計入自己的開支。除了傳統的註冊之外，也提供 Facebook 登入功能，讓註冊認證程序更容易。登入後，首頁有搜尋、類別篩選、月份篩選、明細及總消費金額的顯示功能。</p>
<p>以下介紹將以循序漸進的方式，藉由起承轉合來講述開發的過程與從中所學之經驗、技術。作品詳細資訊：</p>
<ul>
<li><a href="https://github.com/chuni-lin/expense-tracker">GitHub</a></li>
<li><a href="https://obscure-reaches-13602.herokuapp.com/users/login">Heroku</a></li>
</ul>
<h2 id="為何會選擇這個專案">為何會選擇這個專案？</h2>
<h3 id="日常所需">日常所需</h3>
<p>這幾年興起的記帳風潮，除了手機 app 的蓬勃發展所帶動之外，大環境經濟因素也使得人不得不好好控管支出，免得當月光族。<strong>記帳，不只能將花費具體地呈現，還能培養一種「持續」的能力</strong>，在這個瞬息萬變的社會，持之以恆逐漸變得困難，但我們卻可以從日常小事來加以鍛鍊。無論從哪個方面看來，記帳這件事都具有許多益處，而使用一個自己親手打造、磨練的網路帳本，又更增加使用的意願。</p>
<h3 id="商業考量">商業考量</h3>
<p>記帳本屬於使用頻率非常高的網路軟體，加上現在社會傾向一種「個人化」，也就是大家保有相當程度的自我空間、自由，所以這類自我管理用的軟體更有機會受到青睞。<strong>為自己負責，是一種安全感最大化的表現</strong>。可以大膽假設這是一個在當前，即使是在未來更深入的數位時代，都非常具有潛力及前瞻性的產品。</p>
<h3 id="技能鍛鍊">技能鍛鍊</h3>
<p>此專案是以 Node.js 的 Express 框架為基礎所製作的全端產品，對於伺服器的概念及應用、RESTful API 的操作、CRUD 資料操作、使用者驗證等都能有深入淺出的認識，很適合鍛鍊全端開發的基礎能力。除此之外，也訓練了查資料、閱讀資料的關鍵能力。</p>
<h2 id="使用了什麼技術">使用了什麼技術？</h2>
<h3 id="前端技術">前端技術</h3>
<ol>
<li><strong>BootStrap &amp; RWD</strong></li>
<li><strong>Font Awesome</strong></li>
</ol>
<h3 id="後端技術">後端技術</h3>
<ol>
<li>網路伺服器</li>
</ol>
<ul>
<li><strong>Node.js</strong>： JavaScript 執行環境</li>
<li><strong>Express</strong>：伺服器框架</li>
</ul>
<ol start="2">
<li>npm packages</li>
</ol>
<ul>
<li><strong>bcryptjs</strong>：密碼雜湊加密</li>
<li><strong>body-parser</strong>：取得表單（form）資訊</li>
<li><strong>connect-flash</strong>：訊息提示</li>
<li><strong>dotenv</strong>：管理敏感資訊與環境變數</li>
<li><strong>express-handlebars</strong>：樣板引擎(template engine)</li>
<li><strong>express-session</strong>：儲存認證結果，保留使用者登入狀態</li>
<li><strong>handlebars-helpers</strong>：樣版引擎輔助</li>
<li><strong>method-override</strong>：RESTful 路由</li>
<li><strong>passport</strong> : 根據 session 資訊，驗證使用者</li>
<li><strong>passport-facebook</strong>、<strong>passport-local</strong>：本地與第三方登入機制</li>
</ul>
<ol start="3">
<li>資料庫</li>
</ol>
<ul>
<li><strong>MongoDB &amp; Mongoose</strong>： NoSQL Database &amp; ODM 資料庫</li>
<li><strong>Data Schema 資料設計</strong></li>
<li><strong>CRUD 操作</strong></li>
</ul>
<ol start="4">
<li>部署</li>
</ol>
<ul>
<li><strong>Heroku</strong></li>
</ul>
<h3 id="協作技術">協作技術</h3>
<ol>
<li>Git 版控</li>
<li>GitHub</li>
</ol>
<h2 id="哪部分你相對能掌握">哪部分你相對能掌握？</h2>
<p>基本的 CRUD 開發、路由大綱與建構、樣版引擎的使用、使用者認證功能及伺服器與資料庫架設是相對比較容易理解與操作的部分。</p>
<h2 id="哪裡花了最多時間過程中碰到什麼困難又如何克服">哪裡花了最多時間？過程中碰到什麼困難？又如何克服？</h2>
<h3 id="多重篩選功能">多重篩選功能</h3>
<p>篩選的處理是實作中的一大挑戰。同時要篩選類別與月份，遇到非同步的問題——不是只有類別被篩選，就是只有月份被篩選，只好先去查找 JavaScript 中非同步處理的文章來讀，然後練習完再放到專案上。但，過程並非如此順利，在設定兩天的停損點過後依然沒能完成篩選的功能，退而求其次先觀看他人如何實作，藉著模仿再把知識內化給自己。最後學習了 Async/Await 的使用方法，並應用到專案中。</p>
<h3 id="mongodb-及-mongoose-操作資料的方式">MongoDB 及 Mongoose 操作資料的方式</h3>
<p>相較於伺服器有較多的中文資料，資料庫中文資源顯得較少，大多需要查找官方文件或英文資料。然而 Mongoose 的官方文件風格偏學術而不易閱讀，許多操作需要大量自我提問或練習。經過不斷查詢與閱讀、觀摩的過程，建立了基本的 google 能力，接著轉換搜尋策略後，終於找到合適的解決方法。</p>
<h2 id="過程中你有對哪個技術有特別深刻的學習">過程中你有對哪個技術有特別深刻的學習？</h2>
<h3 id="使用者認證系統passport--express-session與密碼雜湊bcryptjs">使用者認證系統（passport &amp; express-session）與密碼雜湊（bcrypt.js）</h3>
<p>對於「登入」與「註冊」這兩件看似簡單但觀念需要很清楚才能理解的原理有深刻的體會。也更能體會 cookie 與 session 在認證上所扮演的角色分別可以對應到伺服器與用戶端。在實作了 Facebook 第三方登入的功能後，於整體印象更深刻。而認證勢必得搭配加密，因為必須讓使用者的密碼在寫入資料庫後不會是明碼 (plain text)。學習中認識了 SHA256 及 bcrypt 兩種雜湊演算法，再詳細閱讀資料後，理解了為什麼雜湊不等於加密，原因在於<strong>加密是可逆的，雜湊是不可逆的</strong>，而雜湊本身的目的在於提高攻擊者的成本。</p>
<p>在研究雜湊這門學問時，讀了許多資安的文章，開始會留意自己寫的 code 是否有被 XSS、CSRF 等攻擊的風險。在這個個資炙手可熱的時代，開發者更應該確保使用者的資訊安全。</p>
<h2 id="下一步計畫">下一步計畫</h2>
<ul>
<li>精進前端能力，學習 Vue 與 React 框架</li>
<li>熟悉資料庫操作與學習關連式資料庫</li>
<li>JavaScript 非同步處理方法，Callback、Promise、 Async/Await</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>ALPHA Camp 自學經驗回顧</title>
            <link>https://jyunyi-lin.github.io/posts/2021/01/alpha-camp-%E8%87%AA%E5%AD%B8%E7%B6%93%E9%A9%97%E5%9B%9E%E9%A1%A7/</link>
            <pubDate>Wed, 06 Jan 2021 14:37:31 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2021/01/alpha-camp-%E8%87%AA%E5%AD%B8%E7%B6%93%E9%A9%97%E5%9B%9E%E9%A1%A7/</guid>
            <description>前言 進入後端課程之後，每個禮拜都過得十分充實。由於後端是自己平常不論在工作或是私底下的學習都比較沒有涉足到的領悟，所以每一章節都是全新的體驗。每一種體驗都帶給我許多成長，而其中最讓人印象深刻的就是不斷地閱讀原文文章這件事。網路上有著許多翻譯後的前端資源，但當來到後端時，往往都需要看英文的說明或者 google，即使平常對於英文並不排斥，也自認具有良好的閱讀能力，但當一開始閱讀「技術文章」時，還是會遇到許多名詞上的不熟悉而讀得不順暢，或者是不知道怎麼使用確切的關鍵字來在 google 海中撈一根針。這篇文章集結了這個月來自我學習及使用搜尋工具的心得，希望能有所幫助。
關於學習 確立問題 找到真正的問題點，有時候是一件很傷腦筋的事。因為有時候你甚至不知道問題出在哪裡。尤其剛開始學習一個新的領域時，你必須先建構出該領域的空間，才能去感受內部的變化。所以很重要的是，在思考欲解決的問題之間，先想想遇到這個問題的過程。這種有脈絡地回溯，會讓整體的輪廓更明顯，也就更容易確立問題出在哪。
當我在思考如何將 select 選單設計成能保存使用者前一次選項時，第一次嘗試了這種思考流程。我先是使用了 Handlebars 的 Built-in Helpers 中的 #if 來試試看，結果發現不可行，於是我跳回到問題發生之前，我想解決的是如何保存選項，而保存選項同義於兩次之間的選項相等，所以我用 handlebars if equal 搜尋，在第一個 stackoverflow 的論壇就找到了答案，但為求更精密的解釋，持續查詢後找到一份有 188 種 handlebars-helpers 的資料，非常有幫助。
當問題確立了之後，尋找到的參考答案也會比較容易理解。
閱讀文件 找到了看起來可能的解答後，接著就要有效率地從一大片草地中找出埋藏寶藏的位置，而且這不是一片普通的草地，而是外國的草地。一開始覺得閱讀英文文件有些困難，但隨著掌握一些訣竅之後，其實都會如同倒吃甘蔗，越來越順。這邊就以上述 188 種 handlebars-helpers 的資料為例，來闡述我的閱讀過程。
馬上看 usage，該份文件的使用方式寫得非常清楚，也告訴你要使用時只需要載入一個主 category，其中就包含多個 helpers。 找到 equal 的同義字，也就是 comparison，看看其中有哪些是符合使用需求的。 選擇了 #is，點進去看它的 code。 藉由 code 來進一步了解用法。 上面的過程其實並沒有需要閱讀到許多文字，只有一開始在找可能解決法的發光點時讀了使用方式，之後大部分都是零星的單字，或者是看 code 來理解。這就跟觀摩同學的作業一樣，你可以選擇先模仿，懂了其中的要領後，再深入發展自己的解釋。
觀摩他人的 code 很多時候，我需要觀摩同學的作業才能找到自己的癥結點。或者，在 CodePen 上尋找好看的 UI 時，也總是觀摩網路上他人的 code。觀摩和抄襲雖然只有一線之隔，但是學習勢必得從模仿開始。重要的是，觀看他人的 code 時，理解對方為何在此處這樣寫，如此一來便能刺激自己去思考，進而激盪出更好的想法。條條大路通羅馬，每個人寫的 code 都不同，但結果可以完全相同，這也是程式語言有趣之處，它告訴我們，其實一開始這就只是一個工具，像學習開車一樣，有的人撞爛一臺車才學會；有的人一插進鑰匙就會駕駛，但結果是每個人學會了開車之後，就都能使用這個工具，而過程就成為自己的回憶。
關於課程 後端開發 後端開發使用的語言雖然還是 JavaScript，但隨著執行環境從瀏覽器到伺服器，使用的方式也有所不同，像是 DOM 之類的操作就行不通。接觸 Node.</description>
            <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>進入後端課程之後，每個禮拜都過得十分充實。由於後端是自己平常不論在工作或是私底下的學習都比較沒有涉足到的領悟，所以每一章節都是全新的體驗。每一種體驗都帶給我許多成長，而其中最讓人印象深刻的就是不斷地閱讀原文文章這件事。網路上有著許多翻譯後的前端資源，但當來到後端時，往往都需要看英文的說明或者 google，即使平常對於英文並不排斥，也自認具有良好的閱讀能力，但當一開始閱讀「技術文章」時，還是會遇到許多名詞上的不熟悉而讀得不順暢，或者是不知道怎麼使用確切的關鍵字來在 google 海中撈一根針。這篇文章集結了這個月來自我學習及使用搜尋工具的心得，希望能有所幫助。</p>
<h2 id="關於學習">關於學習</h2>
<h3 id="確立問題">確立問題</h3>
<p>找到真正的問題點，有時候是一件很傷腦筋的事。因為有時候你甚至不知道問題出在哪裡。尤其剛開始學習一個新的領域時，你必須先建構出該領域的空間，才能去感受內部的變化。所以很重要的是，<strong>在思考欲解決的問題之間，先想想遇到這個問題的過程</strong>。這種有脈絡地回溯，會讓整體的輪廓更明顯，也就更容易確立問題出在哪。</p>
<p>當我在思考如何將 select 選單設計成能保存使用者前一次選項時，第一次嘗試了這種思考流程。我先是使用了 Handlebars 的 Built-in Helpers 中的 #if 來試試看，結果發現不可行，於是我跳回到問題發生之前，我想解決的是如何<strong>保存選項</strong>，而保存選項同義於<strong>兩次之間的選項相等</strong>，所以我用 handlebars if equal 搜尋，在第一個 stackoverflow 的論壇就找到了答案，但為求更精密的解釋，持續查詢後找到一份有 188 種 handlebars-helpers 的<a href="https://github.com/helpers/handlebars-helpers">資料</a>，非常有幫助。</p>
<p>當問題確立了之後，尋找到的參考答案也會比較容易理解。</p>
<h3 id="閱讀文件">閱讀文件</h3>
<p>找到了看起來可能的解答後，接著就要有效率地從一大片草地中找出埋藏寶藏的位置，而且這不是一片普通的草地，而是外國的草地。一開始覺得閱讀英文文件有些困難，但隨著掌握一些訣竅之後，其實都會如同倒吃甘蔗，越來越順。這邊就以上述 188 種 handlebars-helpers 的<a href="https://github.com/helpers/handlebars-helpers">資料</a>為例，來闡述我的閱讀過程。</p>
<ol>
<li>馬上看 usage，該份文件的使用方式寫得非常清楚，也告訴你要使用時只需要載入一個主 category，其中就包含多個 helpers。</li>
<li>找到 equal 的同義字，也就是 comparison，看看其中有哪些是符合使用需求的。</li>
<li>選擇了 #is，點進去看它的 <a href="https://github.com/helpers/handlebars-helpers/blob/master/lib/comparison.js#L367">code</a>。</li>
<li>藉由 code 來進一步了解用法。</li>
</ol>
<p>上面的過程其實並沒有需要閱讀到許多文字，只有一開始在找可能解決法的發光點時讀了使用方式，之後大部分都是零星的單字，或者是看 code 來理解。這就跟觀摩同學的作業一樣，你可以選擇先模仿，懂了其中的要領後，再深入發展自己的解釋。</p>
<h3 id="觀摩他人的-code">觀摩他人的 code</h3>
<p>很多時候，我需要觀摩同學的作業才能找到自己的癥結點。或者，在 CodePen 上尋找好看的 UI 時，也總是觀摩網路上他人的 code。觀摩和抄襲雖然只有一線之隔，但是學習勢必得從模仿開始。重要的是，觀看他人的 code 時，理解對方為何在此處這樣寫，如此一來便能刺激自己去思考，進而激盪出更好的想法。條條大路通羅馬，每個人寫的 code 都不同，但結果可以完全相同，這也是程式語言有趣之處，它告訴我們，其實一開始這就只是一個工具，像學習開車一樣，有的人撞爛一臺車才學會；有的人一插進鑰匙就會駕駛，但結果是每個人學會了開車之後，就都能使用這個工具，而過程就成為自己的回憶。</p>
<h2 id="關於課程">關於課程</h2>
<h3 id="後端開發">後端開發</h3>
<p>後端開發使用的語言雖然還是 JavaScript，但隨著執行環境從瀏覽器到伺服器，使用的方式也有所不同，像是 DOM 之類的操作就行不通。接觸 Node.js 及網路框架 Express 後，覺得世界變得耳目一新，好像魔法一樣，能獨自完成一個 Web Application，前後端都操之在己，很有成就感。最令我印象深刻的是在完成短網址網頁後，終於理解短網址的原理時，覺得學了後端開發真好，這種把一件事從頭到尾抽絲剝繭地去理解、探究真的使人感受到知識之可貴。</p>
<h3 id="非同步處理">非同步處理</h3>
<p>寫作業時總會遇到許多非同步處理的問題，查資料發現這個現象有個名稱叫 callback hell，甚至還有個<a href="https://miro.medium.com/max/1400/0*4MpoPOr7ZMxPmw4E.png">有趣的配圖</a>來表示這種無奈。寫了 2 個 .then() 之後，發現還得再寫 .then() 時，看著畫面總覺得心理不愉快，簡潔癖的我無法容忍這種重複的動作。後來閱讀一些大大的<a href="https://www.oxxostudio.tw/articles/201908/js-async-await.html">技術文章</a>後，開始理解這個狀況。目前正努力地從頭學習 callback, Promise, async / await 演進的過程與概念。</p>
<h2 id="總結">總結</h2>
<p>寫出一個又一個 Web Application 真的令人開心，雖然每一個都需要花許多時間去搜尋解決方法、debug，但從頭到尾參與的過程讓人感受到自己所花的每分每秒都是值得的。當你能同時掌握前後端時，回首去看那些自己常用的網站，會發現那些過去不知道怎麼做出來的功能已經可以大致掌握其脈絡了。過程有長有短，但唯有親自走過的，才會留下痕跡。</p>
]]></content>
        </item>
        
        <item>
            <title>JavaScript 語法筆記：顛倒字串 split()、reverse()、join()</title>
            <link>https://jyunyi-lin.github.io/posts/2020/12/javascript-%E8%AA%9E%E6%B3%95%E7%AD%86%E8%A8%98%E9%A1%9B%E5%80%92%E5%AD%97%E4%B8%B2-splitreversejoin/</link>
            <pubDate>Fri, 04 Dec 2020 17:44:52 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2020/12/javascript-%E8%AA%9E%E6%B3%95%E7%AD%86%E8%A8%98%E9%A1%9B%E5%80%92%E5%AD%97%E4%B8%B2-splitreversejoin/</guid>
            <description>一開始學習 JavaScript 的語法時，總會不知道要在什麼情況下使用。在課程中雖然都懂得如何運用，但如果沒有真正融會貫通，下次碰到題目時也不知道原來有這些方法可以用。這次藉由「顛倒字串」這個題目，也就是當我輸入 &amp;ldquo;Apple&amp;rdquo; 時，電腦要回應我 &amp;ldquo;elppA&amp;rdquo; ，來加強之前學到的陣列及字串處理語法。這邊介紹可以達成這道題目的兩種方法：
1. 使用 split()、reverse()、join() 首先，先來認識這些語法的使用方式。每一個語法名稱的第一個單字代表他是處理什麼的意思。String 就是處理字串的語法；而 Array 就是處理陣列的語法。使用上要注意不要將用在陣列的語法放到字串上囉！
String.prototype.split() split() 可以將字串轉為陣列，在 () 中以一個指定的分割方式來決定分割的位置。例如，在括號的引號 &amp;rsquo;&amp;rsquo; 中沒有輸入任何字符（包括空格），就會以「每一個字串每一個字串」的陣列回傳。
const splitted = &amp;#34;Apple is very delicious&amp;#34;.split(&amp;#39;&amp;#39;) console.log(splitted) // [ &amp;#39;A&amp;#39;, &amp;#39;p&amp;#39;, &amp;#39;p&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39; &amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39; &amp;#39;, &amp;#39;v&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;r&amp;#39;, &amp;#39;y&amp;#39;, &amp;#39; &amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;s&amp;#39; ] 那如果在引號中加入空格呢？
const splitted = &amp;#34;Apple is very delicious&amp;#34;.split(&amp;#39; &amp;#39;) console.log(splitted) // [ &amp;#39;Apple&amp;#39;, &amp;#39;is&amp;#39;, &amp;#39;very&amp;#39;, &amp;#39;delicious&amp;#39; ] 神奇的事發生了！JavaScript 引擎會幫我們用空格來當分割點，回傳給我們一個一個的單字陣列。</description>
            <content type="html"><![CDATA[<p>一開始學習 JavaScript 的語法時，總會不知道要在什麼情況下使用。在課程中雖然都懂得如何運用，但如果沒有真正融會貫通，下次碰到題目時也不知道原來有這些方法可以用。這次藉由「顛倒字串」這個題目，也就是當我輸入 &ldquo;Apple&rdquo; 時，電腦要回應我 &ldquo;elppA&rdquo; ，來加強之前學到的陣列及字串處理語法。這邊介紹可以達成這道題目的兩種方法：</p>
<h2 id="1-使用-splitreversejoin">1. 使用 split()、reverse()、join()</h2>
<p>首先，先來認識這些語法的使用方式。每一個語法名稱的第一個單字代表他是處理什麼的意思。String 就是處理字串的語法；而 Array 就是處理陣列的語法。使用上要注意不要將用在陣列的語法放到字串上囉！</p>
<h3 id="stringprototypesplit">String.prototype.split()</h3>
<p>split() 可以<strong>將字串轉為陣列</strong>，在 () 中以一個指定的分割方式來決定分割的位置。例如，在括號的引號 &rsquo;&rsquo; 中沒有輸入任何字符（包括空格），就會以「每一個字串每一個字串」的<strong>陣列</strong>回傳。</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">const splitted = &#34;Apple is very delicious&#34;.split(&#39;&#39;)
console.log(splitted)
// [
  &#39;A&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;,
  &#39; &#39;, &#39;i&#39;, &#39;s&#39;, &#39; &#39;, &#39;v&#39;,
  &#39;e&#39;, &#39;r&#39;, &#39;y&#39;, &#39; &#39;, &#39;d&#39;,
  &#39;e&#39;, &#39;l&#39;, &#39;i&#39;, &#39;c&#39;, &#39;i&#39;,
  &#39;o&#39;, &#39;u&#39;, &#39;s&#39;
]
</code></pre><p>那如果在引號中加入空格呢？</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">const splitted = &#34;Apple is very delicious&#34;.split(&#39; &#39;)
console.log(splitted) // [ &#39;Apple&#39;, &#39;is&#39;, &#39;very&#39;, &#39;delicious&#39; ]
</code></pre><p>神奇的事發生了！JavaScript 引擎會幫我們用空格來當分割點，回傳給我們一個一個的單字<strong>陣列</strong>。</p>
<h3 id="arrayprototypereverse">Array.prototype.reverse()</h3>
<p>顧名思義就是將<strong>陣列反轉，最後一個元素變成第一個</strong>。讓我們用剛剛的例子來看看：</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">const splitted = &#34;Apple is very delicious&#34;.split(&#39; &#39;).reverse()
console.log(splitted) // [ &#39;delicious&#39;, &#39;very&#39;, &#39;is&#39;, &#39;Apple&#39; ]
</code></pre><p>如果只有一個單字的時候，記得在 split(&rsquo;&rsquo;) 的引號中不要放入空格喔，這樣才能將每一個字母倒轉。</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">const splitted = &#34;Apple&#34;.split(&#39;&#39;).reverse()
console.log(splitted) // [ &#39;e&#39;, &#39;l&#39;, &#39;p&#39;, &#39;p&#39;, &#39;A&#39; ]
</code></pre><p>是不是越來越接近我們要的感覺了？</p>
<h3 id="arrayprototypejoin">Array.prototype.join()</h3>
<p>與 split() 相反，join() 能將<strong>陣列轉成字串</strong>。而括號內的規則也是相同的。來看看例子吧：</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">const splitted = &#34;Apple&#34;.split(&#39;&#39;).reverse().join(&#39;&#39;)
console.log(splitted) // elppA
</code></pre><p>我們成功完成題目了，把它寫成一個可以一直使用的函式吧。</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">function reverseString(str) {
    return str.split(&#39;&#39;).reverse().join(&#39;&#39;)
}
</code></pre><p>句子也可以使用喔，自己試試看吧！</p>
<h2 id="2-使用-for-迴圈">2. 使用 for 迴圈</h2>
<p>第二種方式就簡單多了，用 for 迴圈讓它倒著跑回去就可以。</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">function reverseString(str) {
  let reversed = &#39;&#39;
  for (let i = str.length -1; i &gt;= 0; i--){
    reversed += str[i]
  }
  return reversed
}
</code></pre><h2 id="結語">結語</h2>
<p>一道看起來不怎麼起眼的題目也可以學到很多，尤其是陣列與字串互相轉換的語法在實作上會滿常使用到的。至於把字串顛倒要用在什麼情況呢？總會有那個時候的吧 😂</p>
]]></content>
        </item>
        
        <item>
            <title>ALPHA Camp 學期 2-2 學習心得</title>
            <link>https://jyunyi-lin.github.io/posts/2020/11/alpha-camp-%E5%AD%B8%E6%9C%9F-2-2-%E5%AD%B8%E7%BF%92%E5%BF%83%E5%BE%97/</link>
            <pubDate>Mon, 23 Nov 2020 22:54:02 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2020/11/alpha-camp-%E5%AD%B8%E6%9C%9F-2-2-%E5%AD%B8%E7%BF%92%E5%BF%83%E5%BE%97/</guid>
            <description>OBJECTIVE 學期 2-1 到 2-2 之間，我認為有著飛躍性的成長。很多模糊的觀念在這學期開始變得清晰，也逐漸體會到 JavaScript 這個語言的博大精深，當然坑挖得越深，越是覺得有更多想去理解與學習的。相比於一個月前的自己，現在不僅懂得使用更多的語法，也更能掌控整體寫程式的思考脈絡，比較不容易陷入鑽牛角尖的負面情緒。在寫 code 的過程中，也逐漸培養出要求更精確的命名、排版的一致性與函式的低耦合性。
REFLECTIVE 成功總不是一蹴而就的。進步發生在每一次練習背後找資料的過程。例如遇到新的語法時，除了用教案中的例子來理解，我也會從 Google 中抓取很多資料，把自己會的語言的資料都閱讀過一遍，然後很驚訝地發現原來同一個語法在中文、英文、日文、法文中都有些微相異的解釋方式。我原本就很喜歡日常語言，在學了 JavaScript 之後，我更享受觀察人類語言與電腦語言之間的相關性。
很奇妙的是，我發現閱讀中文資料時會比起閱讀其他語言的資料更難以理解。或許跟語言的特性有關，當英文翻譯成中文時，有時候會顯得有點牽強，但當翻成同有漢字的日文時，卻又沒有這種問題，是否與語言的嚴謹性也有關聯？以上純屬個人意見。
其中我看了一個在講 functional programming 的影片，十分發人省思。裡頭提到純（Pure）與不純的函數、使用高階函數（Higher-order function）而不是用 for、while 來做迴圈、持久化數據結構（Persistent data structure）等等的概念。一個月前我大概影片一開始就直接放棄，但現在我會很有興趣地把它看過一遍又一遍，然後試著梳理出其中的脈絡。我認為這也跟對 JavaScript 有更為深入的認識有關，就像是一開始你不懂到連問問題都沒辦法，一直到你有一些基礎概念而能問出一個問題有異曲同工之妙。問問題也是一門學問。
INTERPRETIVE 無論人類的語言或電腦的語言，若要「持續學習，持續進步」就必須不斷地跳出舒適圈。我們要開口說才能培養出更好的語感，語言的最終目的是完成與其他人的溝通，這是一個絕對雙向的過程，當然閱讀亦是如此，你必須先磨練自己的寫作能力，才能看得懂更深刻晦澀的文章，而每一次練習都在跳出舒適圈。同理可證，學習 JavaScript 的目的是用來與電腦溝通，但是設計這個溝通架構的也是人，所以最終還是在與人溝通。
要是有一個 JavaScript 的語法或者觀念一直無法理解，就好比在現實社會中你不懂為什麼媽媽總是要你如何如何一樣，但若是你不試著跨過你自己的舒適圈與媽媽溝通，情況就會一直僵持下去。試著去讓自己不要陷入這種一直無法理解的負面情緒，打破這個框架去找方法更加認識它，是我認為唯一能持續成長的方法。
就像 Leonard Cohen 在 Anthem 這首歌中的一句歌詞一樣 “There is a crack in everything. That’s how the light gets in.”
DECISIONAL 培養書寫技術文章的能力是我現在想開始進行的。觀摩同學的筆記後發現，唯有自己整理過的，才真正能內化為知識。下一階段要開始學習後端的內容，想必更需要有條理的邏輯與思考力，勉勵自己能將每個章節留下一些紀錄，以供之後需要時能隨時查閱，而不會船過水無痕。</description>
            <content type="html"><![CDATA[<h2 id="objective">OBJECTIVE</h2>
<p>學期 2-1 到 2-2 之間，我認為有著飛躍性的成長。很多模糊的觀念在這學期開始變得清晰，也逐漸體會到 JavaScript 這個語言的博大精深，當然坑挖得越深，越是覺得有更多想去理解與學習的。相比於一個月前的自己，現在不僅懂得使用更多的語法，也更能掌控整體寫程式的思考脈絡，比較不容易陷入鑽牛角尖的負面情緒。在寫 code 的過程中，也逐漸培養出要求<strong>更精確的命名</strong>、<strong>排版的一致性</strong>與<strong>函式的低耦合性</strong>。</p>
<h2 id="reflective">REFLECTIVE</h2>
<p>成功總不是一蹴而就的。進步發生在每一次練習背後找資料的過程。例如遇到新的語法時，除了用教案中的例子來理解，我也會從 Google 中抓取很多資料，把自己會的語言的資料都閱讀過一遍，然後很驚訝地發現原來同一個語法在中文、英文、日文、法文中都有些微相異的解釋方式。我原本就很喜歡日常語言，在學了 JavaScript 之後，我更享受觀察人類語言與電腦語言之間的相關性。</p>
<p>很奇妙的是，我發現閱讀中文資料時會比起閱讀其他語言的資料更難以理解。或許跟語言的特性有關，當英文翻譯成中文時，有時候會顯得有點牽強，但當翻成同有漢字的日文時，卻又沒有這種問題，是否與語言的嚴謹性也有關聯？以上純屬個人意見。</p>
<p>其中我看了一個在講 <a href="https://www.youtube.com/watch?v=e-5obm1G_FY">functional programming</a> 的影片，十分發人省思。裡頭提到純（Pure）與不純的函數、使用高階函數（Higher-order function）而不是用 for、while 來做迴圈、持久化數據結構（Persistent data structure）等等的概念。一個月前我大概影片一開始就直接放棄，但現在我會很有興趣地把它看過一遍又一遍，然後試著梳理出其中的脈絡。我認為這也跟對 JavaScript 有更為深入的認識有關，就像是一開始你<strong>不懂到連問問題都沒辦法</strong>，一直到你<strong>有一些基礎概念而能問出一個問題</strong>有異曲同工之妙。問問題也是一門學問。</p>
<h2 id="interpretive">INTERPRETIVE</h2>
<p>無論人類的語言或電腦的語言，若要「持續學習，持續進步」就必須不斷地跳出舒適圈。我們要開口說才能培養出更好的語感，語言的最終目的是完成與其他人的溝通，這是一個絕對雙向的過程，當然閱讀亦是如此，你必須先磨練自己的寫作能力，才能看得懂更深刻晦澀的文章，而每一次練習都在跳出舒適圈。同理可證，學習 JavaScript 的目的是用來與電腦溝通，但是設計這個溝通架構的也是人，所以最終還是在與人溝通。</p>
<p>要是有一個 JavaScript 的語法或者觀念一直無法理解，就好比在現實社會中你不懂為什麼媽媽總是要你如何如何一樣，但若是你不試著跨過你自己的舒適圈與媽媽溝通，情況就會一直僵持下去。試著去讓自己不要陷入這種一直無法理解的負面情緒，打破這個框架去找方法更加認識它，是我認為唯一能持續成長的方法。</p>
<p>就像 Leonard Cohen 在 <a href="https://www.youtube.com/watch?v=c8-BT6y_wYg">Anthem</a> 這首歌中的一句歌詞一樣 “There is a crack in everything. That’s how the light gets in.”</p>
<h2 id="decisional">DECISIONAL</h2>
<p>培養書寫技術文章的能力是我現在想開始進行的。觀摩同學的筆記後發現，唯有自己整理過的，才真正能內化為知識。下一階段要開始學習後端的內容，想必更需要有條理的邏輯與思考力，勉勵自己能將每個章節留下一些紀錄，以供之後需要時能隨時查閱，而不會船過水無痕。</p>
]]></content>
        </item>
        
        <item>
            <title>What Is Event Loop?</title>
            <link>https://jyunyi-lin.github.io/posts/2020/11/what-is-event-loop/</link>
            <pubDate>Mon, 23 Nov 2020 21:29:07 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2020/11/what-is-event-loop/</guid>
            <description>究竟什麼是 event loop？ Event loop 就字面上的意思來解釋就是「事件圈」。用我的理解來說就是事件的發生順序。但在 JavaScript 中，事件的發生順序卻與我們所以為的有那麼一點不同。而這也就是這篇筆記的主旨，讓我們來好好來了解究竟 event loop 是如何發生在 JavaScript 執行程序中的。進入正題之前，先來認識幾個有點陌生的單字。
名詞解釋 單執行緒（Single-Threaded） JavaScript 是單執行緒的程式語言，白話來說就是由上而下一行一行地執行、一次只做一件事。
堆疊區（Stack） JavaScript 引擎會將執行的程式放到堆疊區（Stack）中，代表他目前正處理到哪個段落。如下圖所示，JavaScript 引擎將任務先放到堆疊區（Stack）中，然後一行一行地執行。而碰到 return 時，就直接脫離堆疊。 圖片來源
事件佇列（Task Queue, Callback Queue） 有一些無法預期什麼時候會被執行的操作，像是 setTimeout、event 監聽器、Ajax，在 JavaScript 中都會以非同步的方式被處理。也就是先被放到事件佇列，等到同步執行的程式碼執行完，再回過頭來處理那些被放到佇列中的任務。 圖片來源
所以，到底什麼是 event loop？ JavaScript 在執行程式的順序是這樣的：
將函式放到堆疊區（Stack）中 如果有非同步的處理程式，例如上述的 setTimeout、event 監聽器、Ajax，會先被放到事件佇列(Callback Queue) 在堆疊區（Stack）中的一般函式被執行 等到堆疊區（Stack）中執行完畢後，再將事件佇列(Callback Queue)中等待執行的任務丟到堆疊區（Stack）中 執行完堆疊區（Stack）中的任務後，再回到事件佇列(Callback Queue)查看是否還有任務要做 這個過程就是 event loop！ 第 4 步驟是我們下一步解題的關鍵，多閱讀幾次，放到你心中。
拆解 setTimeout 函式的謎題 用範例會更好理解，首先我們輸入：
setTimeout(function() {console.log(&amp;#39;delay 0 sec&amp;#39;)}, 0) console.log(&amp;#39;Hello!&amp;#39;) 得到這樣的結果：
Hello! delay 0 sec 可以發現 Hello!</description>
            <content type="html"><![CDATA[<h1 id="究竟什麼是-event-loop">究竟什麼是 event loop？</h1>
<p>Event loop 就字面上的意思來解釋就是「事件圈」。用我的理解來說就是事件的發生順序。但在 JavaScript 中，事件的發生順序卻與我們所以為的有那麼一點不同。而這也就是這篇筆記的主旨，讓我們來好好來了解究竟 event loop 是如何發生在 JavaScript 執行程序中的。進入正題之前，先來認識幾個有點陌生的單字。</p>
<h2 id="名詞解釋">名詞解釋</h2>
<h3 id="單執行緒single-threaded">單執行緒（Single-Threaded）</h3>
<p>JavaScript 是單執行緒的程式語言，白話來說就是由上而下一行一行地執行、一次只做一件事。</p>
<h3 id="堆疊區stack">堆疊區（Stack）</h3>
<p>JavaScript 引擎會將執行的程式放到堆疊區（Stack）中，代表他目前正處理到哪個段落。如下圖所示，JavaScript 引擎將任務先放到堆疊區（Stack）中，然後一行一行地執行。而碰到 return 時，就直接脫離堆疊。
<img src="https://i.imgur.com/Jx00yaG.png"></p>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&feature=emb_title">圖片來源</a></p>
</blockquote>
<h3 id="事件佇列task-queue-callback-queue">事件佇列（Task Queue, Callback Queue）</h3>
<p>有一些無法預期什麼時候會被執行的操作，像是 setTimeout、event 監聽器、Ajax，在 JavaScript 中都會以非同步的方式被處理。也就是先被放到事件佇列，等到同步執行的程式碼執行完，再回過頭來處理那些被放到佇列中的任務。
<img src="https://miro.medium.com/max/1400/1*iHhUyO4DliDwa6x_cO5E3A.gif"></p>
<blockquote>
<p><a href="https://medium.com/@Rahulx1/understanding-event-loop-call-stack-event-job-queue-in-javascript-63dcd2c71ecd">圖片來源</a></p>
</blockquote>
<h2 id="所以到底什麼是-event-loop">所以，到底什麼是 event loop？</h2>
<p>JavaScript 在執行程式的順序是這樣的：</p>
<ol>
<li>將函式放到堆疊區（Stack）中</li>
<li>如果有非同步的處理程式，例如上述的 setTimeout、event 監聽器、Ajax，會先被放到事件佇列(Callback Queue)</li>
<li>在堆疊區（Stack）中的一般函式被執行</li>
<li>等到堆疊區（Stack）中執行完畢後，再將事件佇列(Callback Queue)中等待執行的任務丟到堆疊區（Stack）中</li>
<li>執行完堆疊區（Stack）中的任務後，再回到事件佇列(Callback Queue)查看是否還有任務要做</li>
</ol>
<p>這個過程就是 <strong>event loop</strong>！
<strong>第 4 步驟是我們下一步解題的關鍵，多閱讀幾次，放到你心中。</strong></p>
<h2 id="拆解-settimeout-函式的謎題">拆解 setTimeout 函式的謎題</h2>
<p>用範例會更好理解，首先我們輸入：</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">setTimeout(function() {console.log(&#39;delay 0 sec&#39;)}, 0)
console.log(&#39;Hello!&#39;)
</code></pre><p>得到這樣的結果：</p>
<pre tabindex="0"><code class="language-javascript=" data-lang="javascript=">Hello!
delay 0 sec
</code></pre><p>可以發現 Hello! 比起設置了 0 秒的 setTimeout 函式更早出現，為什麼呢？讓我們套用上述的流程，就可以一覽無遺。</p>
<ol>
<li><code>setTimeout</code> 函式被放入堆疊區（Stack）中</li>
<li>由於 <code>setTimeout</code> 屬於非同步處理程式，因此在堆疊區（Stack）中跑完設定的時間後，會被移到事件佇列(Callback Queue)待機</li>
<li><code>console.log('Hello!')</code>被放入堆疊區（Stack）中</li>
<li>堆疊區（Stack）中的 <code>console.log('Hello!')</code>被執行</li>
<li>印出 <code>console.log('Hello!')</code>結果</li>
<li>此時，堆疊區（Stack）已經沒有任何任務，將 <code>setTimeout</code> 從事件佇列(Callback Queue)中拿出來執行</li>
<li>印出 <code>setTimeout</code> 結果</li>
</ol>
<p><strong>由上面的過程，我們可以推論「setTimeout 設定的等待時間，其實並不能保證它會在設定的時間一到就被執行，JavaScript 引擎要先確定堆疊區（Stack）中的任務都執行完後，才會再回過頭來處理事件佇列(Callback Queue)中的任務。假設我們設定時間為 0sec，只能說它會在大於等於 0sec 後才會執行。」</strong></p>
<h2 id="參考資料">參考資料</h2>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&feature=emb_title">What the heck is the event loop anyway? | Philip Roberts | JSConf EU</a> &gt; <a href="https://pjchender.blogspot.com/2017/08/javascript-learn-event-loop-stack-queue.html">[筆記] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式（Learn event loop, stack, queue, and concurrency mode of JavaScript in depth）</a> &gt; <a href="https://medium.com/@Rahulx1/understanding-event-loop-call-stack-event-job-queue-in-javascript-63dcd2c71ecd">Understanding Event Loop, Call Stack, Event &amp; Job Queue in Javascript</a> &gt; <a href="https://medium.com/@jonathan_wong/what-are-javascript-event-loops-30c72a6ab674">What are Event Loops and What Does It Have to Do with JavaScript?</a> &gt; <a href="https://ithelp.ithome.com.tw/articles/10200054">單執行緒&amp;非同步發生的血案</a></p>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>ALPHA Camp 學期 2-1 學習心得</title>
            <link>https://jyunyi-lin.github.io/posts/2020/11/alpha-camp-%E5%AD%B8%E6%9C%9F-2-1-%E5%AD%B8%E7%BF%92%E5%BF%83%E5%BE%97/</link>
            <pubDate>Sun, 22 Nov 2020 14:16:53 +0800</pubDate>
            
            <guid>https://jyunyi-lin.github.io/posts/2020/11/alpha-camp-%E5%AD%B8%E6%9C%9F-2-1-%E5%AD%B8%E7%BF%92%E5%BF%83%E5%BE%97/</guid>
            <description>為什麼開始寫網頁？ 在工作中偶然有機會要製作一個網頁，當時由於經費的問題，必須自己搞定這個任務。於是就從一本厚重的 HTML、CSS 書籍開始，從學習到刻出一個靜態頁面。當時是在 wordpress 平台上操作，所以基本上不需要太多深入的技巧，頂多改動一下 CSS。不過就因為這次的經驗，讓我對「寫網頁」這件事有了興趣，後來持續自己精進，在某一次的產品計畫中提出希望能自己做出這個產品的 Brand Page。然後從伺服器開始，一直到客戶端的整個過程，使用 Google 大神的資訊漸漸把知識拼圖拼起來。後來發現有 Bootstrap 這個能夠快速拼出網頁模版的平台，一邊使用內建的功能，一邊加入自己的 CSS，終於把一個完整的品牌頁面刻出來。那時候的成就感真是像潮水湧出。
為什麼想學習 JavaScript？ 在跳進這個坑之後，發現原來這是個很深很深看不到最下面的坑。開始開啟開發者工具去看喜歡的網頁的程式碼，試著去理解他的邏輯，然後也想做出跟他一樣的互動效果。結果發現原來這都需要 JavaScript。用 CSS 或許也可以做出動畫效果，但要真正的與使用者互動，非 JavaScript 莫屬。與 HTML、CSS 不同，JavaScript 是一個程式語言，它較為複雜的邏輯概念讓我無法有效率地自己學習，但我想讓品牌網頁更有互動性、更完整，於是我開始尋找線上課程。
所以學了幾個月，有什麼感受？ 我是在學完學期 2-2 才回過頭來做這個 review，原因是當時學完 2-1 時，對 JavaScript 只有初步的了解，沒有一個宏觀、完整的認識，所以無法整理出太多內化的知識。在跑過 API、DOM 及前端使用者體驗後，從一開始覺得這是一個很難理解的程式語言，到現在開始發現他的趣味所在。原本我猜想要學會 JavaScript，大概數學、邏輯能力要很好，後來發現其實不盡然如此。當然在一開始不習慣要如何去思考它時，會顯得自己很笨拙，但跟著課程循序漸進地拆解後，才發現真正重要的，不是「有沒有解題的能力」，而是「如何去思考它運作的能力。」這再次向我說明了，邏輯是要柔軟去對待而不是用死背來應付的。你可以背很多語法，但當你沒掌握到整個撰寫程式的思考脈絡時，你會發現語法就只是語法，而不是解決問題的工具。JavaScript 真的是一門博大精深的語言，有很多可以探索的部分，當你在拆解每一個步驟時，都可以感受到設計者在 JavaScript 引擎上所做的巧思。</description>
            <content type="html"><![CDATA[<h2 id="為什麼開始寫網頁">為什麼開始寫網頁？</h2>
<p>在工作中偶然有機會要製作一個網頁，當時由於經費的問題，必須自己搞定這個任務。於是就從一本厚重的 HTML、CSS 書籍開始，從學習到刻出一個靜態頁面。當時是在 wordpress 平台上操作，所以基本上不需要太多深入的技巧，頂多改動一下 CSS。不過就因為這次的經驗，讓我對「寫網頁」這件事有了興趣，後來持續自己精進，在某一次的產品計畫中提出希望能自己做出這個產品的 Brand Page。然後從伺服器開始，一直到客戶端的整個過程，使用 Google 大神的資訊漸漸把知識拼圖拼起來。後來發現有 Bootstrap 這個能夠快速拼出網頁模版的平台，一邊使用內建的功能，一邊加入自己的 CSS，終於把一個完整的品牌頁面刻出來。那時候的成就感真是像潮水湧出。</p>
<h2 id="為什麼想學習-javascript">為什麼想學習 JavaScript？</h2>
<p>在跳進這個坑之後，發現原來這是個很深很深看不到最下面的坑。開始開啟開發者工具去看喜歡的網頁的程式碼，試著去理解他的邏輯，然後也想做出跟他一樣的互動效果。結果發現原來這都需要 JavaScript。用 CSS 或許也可以做出動畫效果，但要真正的與使用者互動，非 JavaScript 莫屬。與 HTML、CSS 不同，JavaScript 是一個程式語言，它較為複雜的邏輯概念讓我無法有效率地自己學習，但我想讓品牌網頁更有互動性、更完整，於是我開始尋找線上課程。</p>
<h2 id="所以學了幾個月有什麼感受">所以學了幾個月，有什麼感受？</h2>
<p>我是在學完學期 2-2 才回過頭來做這個 review，原因是當時學完 2-1 時，對 JavaScript 只有初步的了解，沒有一個宏觀、完整的認識，所以無法整理出太多內化的知識。在跑過 API、DOM 及前端使用者體驗後，從一開始覺得這是一個很難理解的程式語言，到現在開始發現他的趣味所在。原本我猜想要學會 JavaScript，大概數學、邏輯能力要很好，後來發現其實不盡然如此。當然在一開始不習慣要如何去思考它時，會顯得自己很笨拙，但跟著課程循序漸進地拆解後，才發現真正重要的，不是「有沒有解題的能力」，而是「<strong>如何去思考它運作的能力</strong>。」這再次向我說明了，邏輯是要柔軟去對待而不是用死背來應付的。你可以背很多語法，但當你沒掌握到整個撰寫程式的思考脈絡時，你會發現語法就只是語法，而不是解決問題的工具。JavaScript 真的是一門博大精深的語言，有很多可以探索的部分，當你在拆解每一個步驟時，都可以感受到設計者在 JavaScript 引擎上所做的巧思。</p>
]]></content>
        </item>
        
    </channel>
</rss>
